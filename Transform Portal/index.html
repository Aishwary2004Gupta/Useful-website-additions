<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portal Ring — Box / Knot Worlds</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0f172a;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="scene-canvas"></canvas>

<!-- Import map to resolve bare "three" specifier used by example modules -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<!-- Portal vertex shader -->
<script id="portal-vertex" type="x-shader/x-vertex">
  varying vec3 vWorldPos;
  varying vec3 vWorldNormal;

  void main() {
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    vWorldPos = worldPos.xyz;
    vWorldNormal = normalize(mat3(modelMatrix) * normal);
    gl_Position = projectionMatrix * viewMatrix * worldPos;
  }
</script>

<!-- Portal fragment shader -->
<script id="portal-fragment" type="x-shader/x-fragment">
  uniform sampler2D uTexFront;   // box world
  uniform sampler2D uTexBack;    // knot world
  uniform vec2 uResolution;
  uniform vec3 uCameraPosition;

  varying vec3 vWorldPos;
  varying vec3 vWorldNormal;

  void main() {
    // Direction from fragment to camera
    vec3 viewDir = normalize(uCameraPosition - vWorldPos);

    // Determine which side of the portal we are on
    float side = sign(dot(viewDir, normalize(vWorldNormal)));

    // Screen-space UV for sampling the render targets
    vec2 uv = gl_FragCoord.xy / uResolution;

    vec4 frontColor = texture2D(uTexFront, uv);
    vec4 backColor  = texture2D(uTexBack,  uv);

    // If side > 0 → see front (box), else back (knot)
    vec4 color = (side > 0.0) ? frontColor : backColor;

    gl_FragColor = color;
  }
</script>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

  const canvas = document.getElementById("scene-canvas");

  // -------------------------------------------------------------------
  // Renderer
  // -------------------------------------------------------------------
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  const DPR = Math.min(window.devicePixelRatio, 2);
  renderer.setPixelRatio(DPR);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;

  // -------------------------------------------------------------------
  // Main scene + two "world" scenes (front = box, back = knot)
  // -------------------------------------------------------------------
  const mainScene  = new THREE.Scene();
  const frontScene = new THREE.Scene();
  const backScene  = new THREE.Scene();

  mainScene.background  = new THREE.Color("#020617");
  frontScene.background = new THREE.Color("#020617");
  backScene.background  = new THREE.Color("#020617");

  // -------------------------------------------------------------------
  // Camera & controls
  // -------------------------------------------------------------------
  const camera = new THREE.PerspectiveCamera(
    40,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 0, 9);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 1.2;

  // -------------------------------------------------------------------
  // Lights (add similar lights to all scenes)
  // -------------------------------------------------------------------
  function addLights(scene) {
    const hemi = new THREE.HemisphereLight(0x1f2937, 0x020617, 1.0);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(5, 8, 10);
    scene.add(key);

    const rim = new THREE.PointLight(0x1d4ed8, 0.7, 30);
    rim.position.set(-6, -4, -8);
    scene.add(rim);
  }

  addLights(mainScene);
  addLights(frontScene);
  addLights(backScene);

  // -------------------------------------------------------------------
  // Materials
  // -------------------------------------------------------------------
  const darkBlueMat = new THREE.MeshPhysicalMaterial({
    color: 0x1e3a8a,    // dark blue
    roughness: 0.15,
    metalness: 0.1,
    clearcoat: 1,
    clearcoatRoughness: 0.05,
    transmission: 0.04,
    thickness: 0.9
  });

  // -------------------------------------------------------------------
  // Box world (front)
  // -------------------------------------------------------------------
  const box = new THREE.Mesh(
    new THREE.BoxGeometry(1.4, 1.4, 1.4),
    darkBlueMat.clone()
  );
  frontScene.add(box);

  // -------------------------------------------------------------------
  // Knot world (back)
  // -------------------------------------------------------------------
  const knot = new THREE.Mesh(
    new THREE.TorusKnotGeometry(0.8, 0.32, 160, 32),
    darkBlueMat.clone()
  );
  backScene.add(knot);

  // -------------------------------------------------------------------
  // Ring in main scene
  // -------------------------------------------------------------------
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(3, 0.22, 40, 160),
    new THREE.MeshPhysicalMaterial({
      color: 0xf9fafb,
      roughness: 0.35,
      metalness: 0.0,
      clearcoat: 1,
      clearcoatRoughness: 0.2,
      transmission: 0.4,
      thickness: 0.8
    })
  );
  mainScene.add(ring);

  // -------------------------------------------------------------------
  // Portal surface (flat disc) inside the ring
  // -------------------------------------------------------------------
  const width  = window.innerWidth;
  const height = window.innerHeight;

  const resolution = new THREE.Vector2(width * DPR, height * DPR);

  const rtFront = new THREE.WebGLRenderTarget(width * DPR, height * DPR, {
    depthBuffer: true
  });
  const rtBack = new THREE.WebGLRenderTarget(width * DPR, height * DPR, {
    depthBuffer: true
  });

  const portalVertexShader = document.getElementById("portal-vertex").textContent;
  const portalFragmentShader = document.getElementById("portal-fragment").textContent;

  const portalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTexFront:      { value: rtFront.texture },
      uTexBack:       { value: rtBack.texture },
      uResolution:    { value: resolution },
      uCameraPosition:{ value: camera.position.clone() }
    },
    vertexShader: portalVertexShader,
    fragmentShader: portalFragmentShader,
    transparent: true,
    side: THREE.DoubleSide
  });

  const portalGeo = new THREE.CircleGeometry(2.95, 128);
  const portalMesh = new THREE.Mesh(portalGeo, portalMaterial);
  // Place the disc exactly in the ring plane
  portalMesh.position.set(0, 0, 0);
  mainScene.add(portalMesh);

  // --- Add: clones for objects so they can physically appear in main scene ---
  const boxClone = box.clone();
  boxClone.material = box.material.clone(); // separate material instance
  boxClone.visible = false;
  mainScene.add(boxClone);

  const knotClone = knot.clone();
  knotClone.material = knot.material.clone();
  knotClone.visible = false;
  mainScene.add(knotClone);

  // -------------------------------------------------------------------
  // Animation
  // -------------------------------------------------------------------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const t = clock.getElapsedTime();

    // Move the object in both worlds identically
    const z = Math.sin(t) * 3.5;
    box.position.set(0, 0, z);
    knot.position.set(0, 0, z);

    // Rotate objects
    const r = t * 0.6;
    box.rotation.set(r, r * 1.3, r * 0.7);
    knot.rotation.copy(box.rotation);

    // Rotate ring slowly
    ring.rotation.z = t * 0.18;

    controls.update();

    // --- Add: sync clones' transforms and visibility so object appears to come out of the ring ---
    boxClone.position.copy(box.position);
    boxClone.rotation.copy(box.rotation);
    knotClone.position.copy(knot.position);
    knotClone.rotation.copy(knot.rotation);

    // Determine portal normal in world space and which side the camera is on
    const portalNormal = new THREE.Vector3();
    portalMesh.getWorldDirection(portalNormal); // portal normal (world)
    const portalWorldPos = portalMesh.getWorldPosition(new THREE.Vector3());
    const camToPortal = camera.position.clone().sub(portalWorldPos);
    const portalSide = Math.sign(camToPortal.dot(portalNormal)); // >0 => front/world=box is visible

    // Show the clone only when its world-object has crossed the portal plane toward the camera
    const crossThreshold = 0.05;
    if (portalSide > 0) {
      boxClone.visible = box.position.z > crossThreshold;
      knotClone.visible = false;
    } else {
      knotClone.visible = knot.position.z > crossThreshold;
      boxClone.visible = false;
    }
    // --- end added code ---

    // 1) Render BOX world into rtFront
    renderer.setRenderTarget(rtFront);
    renderer.render(frontScene, camera);

    // 2) Render KNOT world into rtBack
    renderer.setRenderTarget(rtBack);
    renderer.render(backScene, camera);

    // Update camera position uniform for side detection
    portalMaterial.uniforms.uCameraPosition.value.copy(camera.position);

    // 3) Render MAIN scene with portal using both textures
    renderer.setRenderTarget(null);
    renderer.render(mainScene, camera);
  }

  animate();

  // -------------------------------------------------------------------
  // Resize
  // -------------------------------------------------------------------
  window.addEventListener("resize", () => {
    const w = window.innerWidth;
    const h = window.innerHeight;

    renderer.setSize(w, h);

    camera.aspect = w / h;
    camera.updateProjectionMatrix();

    const newDPR = Math.min(window.devicePixelRatio, 2);
    renderer.setPixelRatio(newDPR);

    resolution.set(w * newDPR, h * newDPR);
    rtFront.setSize(w * newDPR, h * newDPR);
    rtBack.setSize(w * newDPR, h * newDPR);
  });
</script>
</body>
</html>
