<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle Animation</title>
    <style>
      html,
      body {
        overflow: hidden;
        height: 100%;
      }
      #canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #00000015;
      }
      /* GUI panel style */
      .dg {
        z-index: 9999 !important;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
      // Initialize scene
      const scene = new THREE.Scene();
      const canvas = document.querySelector("#canvas");

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 2.2, 7);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // controls & clock
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      const clock = new THREE.Clock();

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 7);
      scene.add(ambient, dir);

      // GUI params
      const params = {
        mode: "particles", // 'particles' | 'surface'
        preset: "default",
        particleCount: 20000,
        particleSize: 0.1,
        segments: 120,
        width: 10,
        height: 10,
        amplitude: 0.8,
        frequency: 1.5,
        speed: 1.0,
        wireframe: true,
        colorMap: "height",
        particleColor: "#3498db", // Added particle color parameter
        surfaceColor: "#2ecc71", // Added surface color parameter
        wireframeColor: "#111111", // Added wireframe color parameter
        applyPresetImageLook() {
          this.mode = "surface";
          this.segments = 140;
          this.width = 12;
          this.height = 12;
          this.amplitude = 1.4;
          this.frequency = 1.6;
          this.speed = 0.8;
          this.wireframe = true;
          this.surfaceColor = "#3498db";
          this.wireframeColor = "#111111";
          rebuild();
        },
      };

      // Geometry holders
      let points = null;
      let surface = null;
      let wireframeMesh = null;
      let contourPlane = null;

      const textureLoader = new THREE.TextureLoader();
      // soft disc for points
      const particleTexture = textureLoader.load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      // Create particles Points with consistent colors
      function createParticles() {
        disposeObjects();
        const count = Math.max(
          1000,
          Math.min(50000, Math.floor(params.particleCount))
        );
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        // Parse the color from the parameter
        const particleColor = new THREE.Color(params.particleColor);

        for (let i = 0; i < count; i++) {
          const x = (Math.random() - 0.5) * params.width;
          const z = (Math.random() - 0.5) * params.height;
          const y = 0; // will be animated
          const i3 = i * 3;
          positions[i3] = x;
          positions[i3 + 1] = y;
          positions[i3 + 2] = z;

          // Use the same color for all particles
          colors[i3] = particleColor.r;
          colors[i3 + 1] = particleColor.g;
          colors[i3 + 2] = particleColor.b;
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: params.particleSize,
          sizeAttenuation: true,
          transparent: true,
          alphaMap: particleTexture,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
        });
        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      // Create a surface plane with consistent colors
      function createSurface() {
        disposeObjects();
        const seg = Math.max(4, Math.floor(params.segments));
        const geometry = new THREE.PlaneBufferGeometry(
          params.width,
          params.height,
          seg,
          seg
        );
        geometry.rotateX(-Math.PI / 2); // make X-Z plane

        // set initial y to 0
        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;
        const colors = new Float32Array(count * 3);

        // Parse the surface color from the parameter
        const surfaceColor = new THREE.Color(params.surfaceColor);

        // compute initial heights and use consistent colors
        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const x = positions[i3];
          const z = positions[i3 + 2];
          const y = 0;
          positions[i3 + 1] = y;

          // Use the same color for all vertices
          colors[i3] = surfaceColor.r;
          colors[i3 + 1] = surfaceColor.g;
          colors[i3 + 2] = surfaceColor.b;
        }
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();

        // Phong material with vertex colors
        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          shininess: 40,
          side: THREE.DoubleSide,
          flatShading: false,
        });

        surface = new THREE.Mesh(geometry, material);
        scene.add(surface);

        // optional wireframe overlay
        if (params.wireframe) {
          const geo = new THREE.WireframeGeometry(geometry);
          const wireframeColor = new THREE.Color(params.wireframeColor);
          wireframeMesh = new THREE.LineSegments(
            geo,
            new THREE.LineBasicMaterial({
              color: wireframeColor,
              linewidth: 1,
            })
          );
          scene.add(wireframeMesh);
        }

        // optional contour base plane (simple tinted plane with transparency)
        contourPlane = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(
            params.width * 1.05,
            params.height * 1.05,
            1,
            1
          ),
          new THREE.MeshBasicMaterial({
            color: 0xdddddd,
            transparent: true,
            opacity: 0.45,
          })
        );
        contourPlane.rotateX(-Math.PI / 2);
        contourPlane.position.y = -1.8;
        scene.add(contourPlane);
      }

      // Dispose any previous objects
      function disposeObjects() {
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        if (surface) {
          scene.remove(surface);
          surface.geometry.dispose();
          surface.material.dispose();
          surface = null;
        }
        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMesh.geometry.dispose();
          wireframeMesh.material.dispose();
          wireframeMesh = null;
        }
        if (contourPlane) {
          scene.remove(contourPlane);
          contourPlane.geometry.dispose();
          contourPlane.material.dispose();
          contourPlane = null;
        }
      }

      // Rebuild depending on params.mode
      function rebuild() {
        if (params.mode === "particles") {
          createParticles();
        } else {
          createSurface();
        }
      }

      // initial build
      rebuild();

      // GUI
      const gui = new dat.GUI({ closed: true }); // Start with GUI closed
      gui
        .add(params, "mode", ["particles", "surface"])
        .name("Mode")
        .onChange(rebuild);
      gui.add(params, "applyPresetImageLook").name("Apply Image Look");

      const pFolder = gui.addFolder("Particles");
      pFolder
        .add(params, "particleCount", 1000, 50000, 1000)
        .name("Count")
        .onFinishChange(() => {
          if (params.mode === "particles") rebuild();
        });
      pFolder
        .add(params, "particleSize", 0.01, 0.5, 0.01)
        .name("Size")
        .onChange(() => {
          if (points) points.material.size = params.particleSize;
        });
      pFolder
        .addColor(params, "particleColor")
        .name("Color")
        .onChange(() => {
          if (params.mode === "particles") rebuild();
        });
      pFolder.open();

      const sFolder = gui.addFolder("Surface");
      sFolder
        .add(params, "segments", 4, 300, 1)
        .name("Segments")
        .onFinishChange(() => {
          if (params.mode === "surface") rebuild();
        });
      sFolder
        .add(params, "width", 1, 30, 0.1)
        .name("Width")
        .onFinishChange(rebuild);
      sFolder
        .add(params, "height", 1, 30, 0.1)
        .name("Height")
        .onFinishChange(rebuild);
      sFolder
        .add(params, "wireframe")
        .name("Wireframe")
        .onChange(() => {
          if (params.mode === "surface") rebuild();
        });
      sFolder
        .addColor(params, "surfaceColor")
        .name("Surface Color")
        .onChange(() => {
          if (params.mode === "surface") rebuild();
        });
      sFolder
        .addColor(params, "wireframeColor")
        .name("Wireframe Color")
        .onChange(() => {
          if (params.mode === "surface") rebuild();
        });
      sFolder.open();

      const wFolder = gui.addFolder("Waves");
      wFolder.add(params, "amplitude", 0, 3, 0.01).name("Amplitude");
      wFolder.add(params, "frequency", 0, 6, 0.01).name("Frequency");
      wFolder.add(params, "speed", 0, 3, 0.01).name("Speed");
      wFolder.open();

      // Animation loop - update heights ONLY, colors remain constant
      function animate() {
        const t = clock.getElapsedTime() * params.speed;

        if (points) {
          const pos = points.geometry.attributes.position.array;
          const count = pos.length / 3;
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            // wave from combined sin/cos for nicer surface
            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
            pos[i3 + 1] = y;
          }
          points.geometry.attributes.position.needsUpdate = true;
          // NO COLOR UPDATES - colors remain constant
        }

        if (surface) {
          const pos = surface.geometry.attributes.position.array;
          const vertCount = pos.length / 3;

          // Only update positions, not colors
          for (let i = 0; i < vertCount; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
            pos[i3 + 1] = y;
          }

          surface.geometry.attributes.position.needsUpdate = true;
          surface.geometry.computeVertexNormals();
          // NO COLOR UPDATES - colors remain constant

          if (wireframeMesh) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(
              surface.geometry
            );
          }
        }

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // handle resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Optional: Add keyboard shortcut to toggle GUI (press 'H')
      window.addEventListener("keydown", (e) => {
        if (e.key === "h" || e.key === "H") {
          gui.closed = !gui.closed;
        }
      });

      animate();
    </script>
  </body>
</html>
