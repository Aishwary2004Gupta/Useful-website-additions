<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Depixelation Effect - Working Version</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #74B7FF;
    font-family: Arial;
  }

  #control-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 14px;
    width: 220px;
    background: rgba(0,0,0,0.65);
    color: white;
    border-radius: 10px;
    backdrop-filter: blur(10px);
  }

  #progressSlider {
    width: 100%;
  }
</style>
</head>

<body>

<div id="control-panel">
  <h3>Depixelation Controls</h3>
  <label>Progress: <span id="progressValue">0.00</span></label>
  <input type="range" id="progressSlider" min="0" max="1" step="0.001" value="0">
</div>

<canvas id="webgl"></canvas>

<!-- ðŸŸ¦ ES MODULE SCRIPT (THIS FIXES YOUR ISSUE) -->
<script type="module">
import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/ShaderPass.js";

// Canvas
const canvas = document.getElementById("webgl");
const scene = new THREE.Scene();

// Camera
const aspect = window.innerWidth / window.innerHeight;
const camera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.01, 500);
camera.position.set(0, 0, 10);
camera.zoom = 100;
camera.updateProjectionMatrix();
scene.add(camera);

// Renderer
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);

// Image
const texture = new THREE.TextureLoader().load(
  "https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg"
);
const plane = new THREE.Mesh(
  new THREE.PlaneGeometry(2 * aspect, 2),
  new THREE.MeshBasicMaterial({ map: texture })
);
scene.add(plane);

// Shader
const DepixelationShader = {
  uniforms: {
    progress: { value: 0.0 },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    time: { value: 0 },
    tDiffuse: { value: null }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float progress;
    uniform vec2 resolution;
    uniform float time;
    uniform sampler2D tDiffuse;

    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    const float LEVELS = 5.0;

    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;

      float basePixelSize = pow(2.0, LEVELS);
      float currentLevel = floor(progress * LEVELS);
      float currentPixelSize = max(basePixelSize / pow(2.0, currentLevel), 1.0);

      float rowCount = ceil(resolution.y / currentPixelSize);
      float colCount = ceil(resolution.x / currentPixelSize);
      float totalPixels = rowCount * colCount;

      float levelProgress = fract(progress * LEVELS) * totalPixels;
      float currentRow = floor(levelProgress / colCount);
      float currentCol = mod(levelProgress, colCount);

      vec2 grid = floor(uv * resolution / currentPixelSize);

      float row = floor(rowCount - grid.y - 1.0);
      float col = floor(grid.x);

      vec2 finalUv;
      vec4 extra = vec4(0.0);

      if (currentPixelSize <= 1.0) {
        finalUv = uv;
      } else if (row < currentRow || (row == currentRow && col <= currentCol)) {
        vec2 snap = currentPixelSize / resolution;
        finalUv = snap * floor(uv / snap);

        if (row == currentRow) {
          float tw = sin(time * 10.0 + random(vec2(col, row)) * 10.0) + 1.0;
          extra = vec4(0.005 * tw * 20.0);
        }
      } else {
        float bigger = currentPixelSize * 2.0;
        vec2 snap = bigger / resolution;
        finalUv = snap * floor(uv / snap);
      }

      gl_FragColor = texture2D(tDiffuse, finalUv) + extra;
    }
  `
};

// Postprocessing
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const shaderPass = new ShaderPass(DepixelationShader);
composer.addPass(shaderPass);

// Slider UI
const slider = document.getElementById("progressSlider");
const label = document.getElementById("progressValue");

slider.oninput = () => {
  shaderPass.uniforms.progress.value = parseFloat(slider.value);
  label.textContent = slider.value;
};

// Resize
window.onresize = () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.left = -window.innerWidth / window.innerHeight;
  camera.right = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  shaderPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
};

// Animate
let t = 0;
function animate() {
  requestAnimationFrame(animate);
  t += 0.01;
  shaderPass.uniforms.time.value = t;
  controls.update();
  composer.render();
}
animate();
</script>

</body>
</html>
