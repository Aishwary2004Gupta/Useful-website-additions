<!DOCTYPE html>
<html>
<head>
    <title>WebGPU-style Low-Poly Render</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
let composer, camera, scene, renderer;
const CELL_SIZE = 0.8;
const GRID_RES = 128;

function createProceduralGeometry() {
    const geometry = new THREE.PlaneGeometry(50, 50, GRID_RES, GRID_RES);
    const positions = geometry.attributes.position.array;
    
    // Fractal displacement using combined noise layers
    for(let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 2];
        
        positions[i + 1] = 
            Math.abs(Math.sin(x * 2) * Math.cos(z * 1.5)) * 3 +
            Math.pow(Math.abs(noise.simplex2(x * 0.5, z * 0.5)), 2) * 4;
    }
    
    geometry.computeVertexNormals();
    return geometry;
}

function init() {
    // Scene setup
    scene = new THREE.Scene();
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Advanced material setup
    const material = new THREE.MeshPhongMaterial({
        color: 0x2a0a0a,
        specular: 0xff4040,
        shininess: 150,
        flatShading: true,
        side: THREE.DoubleSide
    });

    // Procedural geometry generation
    const terrain = new THREE.Mesh(createProceduralGeometry(), material);
    terrain.rotation.x = -Math.PI / 2;
    scene.add(terrain);

    // Modern lighting setup
    const directionalLight = new THREE.DirectionalLight(0xff6060, 3);
    directionalLight.position.set(-15, 25, 15);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xaa2020, 50, 100);
    pointLight.position.set(10, 15, -10);
    scene.add(pointLight);

    // Post-processing pipeline
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));

    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Camera setup
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(35, 25, 35);

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        // Dynamic camera movement
        const time = Date.now() * 0.001;
        camera.position.x = 35 * Math.sin(time * 0.3);
        camera.position.z = 35 * Math.cos(time * 0.3);
        camera.lookAt(scene.position);

        // Light animation
        directionalLight.intensity = 2 + Math.sin(time) * 0.5;
        pointLight.position.y = 15 + Math.sin(time * 0.7) * 3;

        composer.render();
    }

    window.addEventListener('resize', onWindowResize);
    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

init();
</script>
</body>
</html>