<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Half-Half Wave</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
  }
  canvas { width: 100%; height: 100%; display: block; }
</style>
</head>

<body>
<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

<script>
/* -----------------------------------------
   Base Setup
------------------------------------------*/
const scene = new THREE.Scene();
scene.background = new THREE.Color("#ffffff");

const canvas = document.getElementById("canvas");

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.set(-10, 6, 12);

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.localClippingEnabled = true;

const clock = new THREE.Clock();

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(4, 8, 4);
scene.add(light);

/* -----------------------------------------
   Parameters
------------------------------------------*/
const params = {
  amplitude: 1.2,
  frequency: 1.5,
  speed: 1.2,
  particleCount: 20000,
  background: "light",   // toggle
};

/* -----------------------------------------
   Color Function
------------------------------------------*/
function heightToColor(t) {
  t = THREE.MathUtils.clamp(t, 0, 1);
  const c = new THREE.Color();
  if (t < 0.33) c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
  else if (t < 0.66) {
    const tt = (t - 0.33) / 0.33;
    c.setRGB(tt * 0.4, 0.9, tt * 0.6);
  } else {
    const tt = (t - 0.66) / 0.34;
    c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
  }
  return c;
}

/* -----------------------------------------
   Wave Function
------------------------------------------*/
function applyWave(geometry, time) {
  const pos = geometry.attributes.position.array;

  for (let i = 0; i < pos.length; i += 3) {
    const x = pos[i];
    const z = pos[i + 2];

    pos[i + 1] =
      Math.sin((x * 0.5 + time) * params.frequency) *
      Math.cos((z * 0.5 + time) * params.frequency) *
      params.amplitude +
      1.2;
  }

  geometry.attributes.position.needsUpdate = true;
}

/* -----------------------------------------
   Half-Half Wave Creation
------------------------------------------*/
let halfSurface = null;
let halfParticles = null;

function createHalfHalf() {
  // REMOVE OLD OBJECTS
  if (halfSurface) scene.remove(halfSurface);
  if (halfParticles) scene.remove(halfParticles);

  /* ---- Left: Surface ---- */
  const geo = new THREE.PlaneGeometry(14, 14, 140, 140);
  geo.rotateX(-Math.PI / 2);

  const colors = new Float32Array(geo.attributes.position.count * 3);
  geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  halfSurface = new THREE.Mesh(
    geo,
    new THREE.MeshPhongMaterial({
      vertexColors: true,
      clippingPlanes: [new THREE.Plane(new THREE.Vector3(1, 0, 0), 0)]
    })
  );
  scene.add(halfSurface);

  /* ---- Right: Particles ---- */
  const count = params.particleCount;
  const pos = new Float32Array(count * 3);
  const col = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    pos[i3] = (Math.random() - 0.5) * 14;
    pos[i3 + 1] = 0;
    pos[i3 + 2] = (Math.random() - 0.5) * 14;

    const c = new THREE.Color().setHSL(Math.random(), 0.6, 0.55);
    col.set([c.r, c.g, c.b], i3);
  }

  const pGeo = new THREE.BufferGeometry();
  pGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  pGeo.setAttribute("color", new THREE.BufferAttribute(col, 3));

  halfParticles = new THREE.Points(
    pGeo,
    new THREE.PointsMaterial({
      size: 0.12,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      clippingPlanes: [new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0)]
    })
  );
  scene.add(halfParticles);
}

createHalfHalf();

/* -----------------------------------------
   GUI
------------------------------------------*/
const gui = new dat.GUI();

gui.add(params, "background", ["light", "dark"])
  .name("Background")
  .onChange((v) => {
    scene.background = new THREE.Color(v === "light" ? "#ffffff" : "#111111");
  });

/* -----------------------------------------
   Animation Loop
------------------------------------------*/
function animate() {
  requestAnimationFrame(animate);

  const t = clock.getElapsedTime() * params.speed;

  if (halfSurface) {
    applyWave(halfSurface.geometry, t);

    // Re-color surface
    const pos = halfSurface.geometry.attributes.position.array;
    const col = halfSurface.geometry.attributes.color.array;

    let min = Infinity, max = -Infinity;
    for (let i = 0; i < pos.length; i += 3) {
      min = Math.min(min, pos[i + 1]);
      max = Math.max(max, pos[i + 1]);
    }
    const range = max - min;

    for (let i = 0; i < pos.length; i += 3) {
      const t2 = (pos[i + 1] - min) / range;
      const c = heightToColor(t2);
      col.set([c.r, c.g, c.b], i);
    }
    halfSurface.geometry.attributes.color.needsUpdate = true;
  }

  if (halfParticles) {
    applyWave(halfParticles.geometry, t);
  }

  renderer.render(scene, camera);
}

animate();

/* -----------------------------------------
   Resize
------------------------------------------*/
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
