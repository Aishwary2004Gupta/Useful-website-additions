<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dithering Shader Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .ui {
      position: absolute;
      top: 1rem;
      left: 1rem;
      color: white;
      z-index: 10;
      font-family: sans-serif;
    }
    .ui label {
      display: block;
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="ui">
    <label>
      Pixel Size:
      <input type="range" id="pixelSize" min="1" max="20" value="4" />
    </label>
    <label>
      Grayscale:
      <input type="checkbox" id="grayscale" />
    </label>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- postprocessing or Effect composer from three.js examples (if needed) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

  <script>
  // ---------------------- Shader definition ----------------------
  const DitheringShader = {
    uniforms: {
      "tDiffuse": { value: null },
      "resolution": { value: new THREE.Vector2(1,1) },
      "pixelSize": { value: 4.0 },
      "grayscaleOnly": { value: 0.0 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform vec2 resolution;
      uniform float pixelSize;
      uniform float grayscaleOnly;

      // 4x4 Bayer (ordered dithering) threshold matrix (normalized 0.0 to 1.0)
      float bayerThreshold(int x, int y) {
        // classic 4x4 Bayer matrix
        int idx = y * 4 + x;
        int mat[16];
        mat[0] = 0; mat[1] = 8; mat[2] = 2; mat[3] = 10;
        mat[4] = 12; mat[5] = 4; mat[6] = 14; mat[7] = 6;
        mat[8] = 3; mat[9] = 11; mat[10] = 1; mat[11] = 9;
        mat[12] = 15; mat[13] = 7; mat[14] = 13; mat[15] = 5;
        return float(mat[idx]) / 16.0;
      }

      void main() {
        // Pixelation: snap uv to grid
        vec2 uv = vUv;
        vec2 pixel = pixelSize / resolution;
        uv = floor(uv / pixel) * pixel + pixel * 0.5;

        vec4 color = texture2D(tDiffuse, uv);

        // optionally convert to luminance/grayscale
        if (grayscaleOnly > 0.5) {
          float lum = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
          color = vec4(vec3(lum), 1.0);
        }

        // find position in 4x4 Bayer cell
        vec2 pos = gl_FragCoord.xy;
        int x = int(mod(pos.x / pixelSize, 4.0));
        int y = int(mod(pos.y / pixelSize, 4.0));
        float threshold = bayerThreshold(x, y);

        // apply dithering: compare brightness vs threshold
        vec3 result = color.rgb;
        result = floor(result + threshold);
        result = clamp(result, 0.0, 1.0);

        gl_FragColor = vec4(result, color.a);
      }
    `
  };

  // ---------------------- Setup Three.js scene & composer ----------------------
  const container = document.getElementById('container');
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

  const material = new THREE.MeshBasicMaterial({
    map: null  // we will set texture later
  });

  // plane to render the image
  const quad = new THREE.Mesh(
    new THREE.PlaneGeometry(2, 2),
    material
  );
  scene.add(quad);

  // postprocessing
  const composer = new THREE.EffectComposer(renderer);
  const renderPass = new THREE.RenderPass(scene, camera);
  const shaderPass = new THREE.ShaderPass(DitheringShader);
  composer.addPass(renderPass);
  composer.addPass(shaderPass);

  // load texture (an image) to apply shader on
  const loader = new THREE.TextureLoader();
  loader.crossOrigin = "";  // allow CORS if needed
  loader.load("https://source.unsplash.com/random/1024x1024?sig=7", (tex) => {
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    material.map = tex;
    material.needsUpdate = true;
    onWindowResize();
    animate();
  });

  function onWindowResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    renderer.setSize(w, h);
    composer.setSize(w, h);
    DitheringShader.uniforms.resolution.value.set(w, h);
  }
  window.addEventListener('resize', onWindowResize);

  // UI hooks
  const pixelSlider = document.getElementById('pixelSize');
  const grayscaleChk = document.getElementById('grayscale');
  pixelSlider.addEventListener('input', () => {
    shaderPass.uniforms.pixelSize.value = parseFloat(pixelSlider.value);
  });
  grayscaleChk.addEventListener('change', () => {
    shaderPass.uniforms.grayscaleOnly.value = grayscaleChk.checked ? 1.0 : 0.0;
  });

  // animation loop
  function animate() {
    requestAnimationFrame(animate);
    composer.render();
  }
  </script>
</body>
</html>
