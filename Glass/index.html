<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactable Water Sphere (ESM Fix)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
  </style>
</head>
<body>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

// ---------------------------------------------
// BASIC SCENE SETUP
// ---------------------------------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

camera.position.z = -2.5;
camera.position.x = -5;

const ambient = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambient);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ---------------------------------------------
// ENVIRONMENT
// ---------------------------------------------
let loaded = 0;
const loading = () => loaded++;

const ENV_URL = "https://s.halvves.com/gregzaal-venicedawn.jpg";

const loader = new THREE.TextureLoader();
const reflectionCube = loader.load(ENV_URL, loading);
const refractionCube = loader.load(ENV_URL, loading);

reflectionCube.mapping = THREE.EquirectangularReflectionMapping;
refractionCube.mapping = THREE.EquirectangularRefractionMapping;

scene.background = reflectionCube;
scene.environment = reflectionCube;

// ---------------------------------------------
// GEOMETRY + MATERIALS
// ---------------------------------------------
const geometry = new THREE.SphereGeometry(2, 128, 128);
const base = geometry.attributes.position.array.slice();

const refractionMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xc3e4f9,
  envMap: refractionCube,
  metalness: 0.2,
  roughness: 0,
  ior: 1.1,
  transmission: 0.6,
  side: THREE.DoubleSide,
});

const reflectionMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xc3e4f9,
  envMap: reflectionCube,
  metalness: 0.3,
  roughness: 0,
  transmission: 1,
  transparent: true,
  ior: 1.1,
  side: THREE.DoubleSide,
});

const refractionSphere = new THREE.Mesh(geometry, refractionMaterial);
const reflectionSphere = new THREE.Mesh(geometry, reflectionMaterial);

const sphere = new THREE.Object3D();
sphere.add(refractionSphere);
sphere.add(reflectionSphere);
scene.add(sphere);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ---------------------------------------------
// INTERACTIVE WATER RIPPLE SYSTEM
// ---------------------------------------------
const vertexCount = geometry.attributes.position.count;
const rippleStrength = new Float32Array(vertexCount).fill(0);
const rippleVelocity = new Float32Array(vertexCount).fill(0);

const RIPPLE_DAMPING = 0.975;
const RIPPLE_SPEED = 0.03;
const RIPPLE_FORCE = 0.6;

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function addRipple(point) {
  const pos = geometry.attributes.position;

  let closest = 0;
  let min = Infinity;
  const temp = new THREE.Vector3();

  for (let i = 0; i < vertexCount; i++) {
    temp.set(pos.getX(i), pos.getY(i), pos.getZ(i));
    const d = temp.distanceTo(point);
    if (d < min) {
      min = d;
      closest = i;
    }
  }

  rippleVelocity[closest] += RIPPLE_FORCE;
}

function pointerEvent(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(pointer, camera);
  const hit = raycaster.intersectObject(reflectionSphere)[0];
  if (hit) addRipple(hit.point);
}

window.addEventListener("pointermove", pointerEvent);
window.addEventListener("pointerdown", pointerEvent);

// ---------------------------------------------
// ANIMATION LOOP
// ---------------------------------------------
function animate(dt) {
  requestAnimationFrame(animate);
  controls.update();

  if (loaded !== 2) return;

  const pos = geometry.attributes.position;

  // Base waving motion
  pos.array.forEach((v, i, arr) => {
    const mod = i % 3;

    if (mod === 0)
      arr[i] = base[i] + Math.sin(base[i + 1] * 3 + dt * 0.002) * 0.1;

    if (mod === 1)
      arr[i] = base[i] + Math.cos(base[i - 1] * 5 + dt * 0.003) * 0.08;

    if (mod === 2)
      arr[i] = base[i] + Math.sin(base[i - 2] * 25 + dt * 0.01) * 0.03;
  });

  // Ripple physics
  for (let i = 0; i < vertexCount; i++) {
    rippleVelocity[i] += -rippleStrength[i] * RIPPLE_SPEED;
    rippleStrength[i] += rippleVelocity[i];
    rippleVelocity[i] *= RIPPLE_DAMPING;
  }

  // Apply ripple displacement
  for (let i = 0; i < vertexCount; i++) {
    const offset = rippleStrength[i] * 0.15;
    pos.setXYZ(i, pos.getX(i), pos.getY(i) + offset, pos.getZ(i));
  }

  geometry.computeVertexNormals();
  geometry.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener("resize", () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>

</body>
</html>
