<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FluidGlass in Vanilla JS</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0c0618;
    }
    canvas {
      display: block;
    }
    .overlay-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: sans-serif;
      font-size: clamp(24px, 5vw, 80px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="overlay-text">React Bits</div>
  <script type="module">
    // import * as THREE from 'three'
    // import * as THREE from './three.module.js' // âœ… valid

    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js'
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/GLTFLoader.js'
    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/RGBELoader.js'

    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(15, innerWidth/innerHeight, 0.1, 100)
    camera.position.z = 20

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
    renderer.setSize(innerWidth, innerHeight)
    renderer.setPixelRatio(devicePixelRatio)
    document.body.appendChild(renderer.domElement)

    // Add a environment for refraction
    const pmrem = new THREE.PMREMGenerator(renderer)
    new RGBELoader().setDataType(THREE.UnsignedByteType)
      .load('/assets/env/royal_esplanade_1k.hdr', (hdr) => {
        const envMap = pmrem.fromEquirectangular(hdr).texture
        scene.environment = envMap
      })

    const loader = new GLTFLoader()
    let lensMesh

    loader.load('/assets/3d/lens.glb', (gltf) => {
      lensMesh = gltf.scene.children[0]
      lensMesh.rotation.x = Math.PI / 2
      lensMesh.scale.setScalar(0.25)

      lensMesh.material = new THREE.MeshPhysicalMaterial({
        transmission: 1,
        roughness: 0,
        thickness: 5,
        ior: 1.15,
        clearcoat: 1,
        clearcoatRoughness: 0,
        metalness: 0,
        transparent: true
      })

      scene.add(lensMesh)
    })

    const pointer = new THREE.Vector2()
    window.addEventListener('pointermove', (e) =>
      pointer.set(e.clientX/innerWidth*2-1, -(e.clientY/innerHeight)*2+1)
    )

    function animate() {
      requestAnimationFrame(animate)
      if (lensMesh) {
        lensMesh.rotation.y += 0.002
        // subtle parallax based on pointer
        lensMesh.position.x += (pointer.x*4 - lensMesh.position.x)*0.05
        lensMesh.position.y += (pointer.y*4 - lensMesh.position.y)*0.05
      }
      renderer.render(scene, camera)
    }
    animate()

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(innerWidth, innerHeight)
    })
  </script>
</body>
</html>
