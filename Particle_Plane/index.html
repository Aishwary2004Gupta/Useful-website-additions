<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wave Animation ‚Äì Half-Half Default</title>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #00000015;
    }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .dg { z-index: 99999 !important; }
  </style>
</head>

<body>
<canvas id="canvas"></canvas>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

<script>
/* ============================================================
      BASE SETUP
============================================================ */
const scene = new THREE.Scene();
const canvas = document.querySelector("#canvas");

const camera = new THREE.PerspectiveCamera(
  65, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.set(-10, 6, 12);

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.localClippingEnabled = true;

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const clock = new THREE.Clock();

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(6, 8, 6);
scene.add(dir);

const particleTexture = new THREE.TextureLoader().load(
  "https://threejs.org/examples/textures/sprites/disc.png"
);

/* ============================================================
      PARAMETERS
============================================================ */
const params = {
  mode: "half-half",     // ‚≠ê DEFAULT MODE = HALF-HALF
  amplitude: 1.2,
  frequency: 1.5,
  speed: 1.2,

  // Particle settings
  particleCount: 20000,
  particleSize: 0.12,

  // Surface settings
  width: 14,
  height: 14,
  segments: 140,
  wireframe: true,

  // Pause system
  playPause: () => togglePause()
};

/* ============================================================
      PAUSE SYSTEM
============================================================ */
let paused = false;
let savedTime = 0;
let playPauseController;

function togglePause() {
  paused = !paused;
  playPauseController.name(paused ? "‚ñ∂ Play" : "‚è∏ Pause");
}

/* ============================================================
      OBJECT REFERENCES
============================================================ */
let surface = null;
let wireframeMesh = null;
let particles = null;

let halfSurface = null;
let halfParticles = null;
let halfWireframe = null;

/* Remove old objects safely */
function remove(obj) {
  if (!obj) return;
  scene.remove(obj);
  if (obj.geometry) obj.geometry.dispose();
  if (obj.material) obj.material.dispose();
}

function clearScene() {
  remove(surface); surface = null;
  remove(wireframeMesh); wireframeMesh = null;
  remove(particles); particles = null;

  remove(halfSurface); halfSurface = null;
  remove(halfParticles); halfParticles = null;
  remove(halfWireframe); halfWireframe = null;
}

/* ============================================================
      UTIL FUNCTIONS
============================================================ */
function heightToColor(t) {
  t = THREE.MathUtils.clamp(t, 0, 1);
  const c = new THREE.Color();

  if (t < 0.33) c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
  else if (t < 0.66) {
    const tt = (t - 0.33) / 0.33;
    c.setRGB(tt * 0.4, 0.9, tt * 0.6);
  } else {
    const tt = (t - 0.66) / 0.34;
    c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
  }
  return c;
}

function applyWaveToGeometry(geo, t) {
  const pos = geo.attributes.position.array;
  const yOffset = 1.2;

  for (let i = 0; i < pos.length; i += 3) {
    const x = pos[i];
    const z = pos[i + 2];
    pos[i + 1] =
      Math.sin((x * 0.5 + t) * params.frequency) *
      Math.cos((z * 0.5 + t) * params.frequency) *
      params.amplitude +
      yOffset;
  }
  geo.attributes.position.needsUpdate = true;
}

function applyColorToGeometry(geo) {
  const pos = geo.attributes.position.array;
  const col = geo.attributes.color.array;

  let min = Infinity, max = -Infinity;

  for (let i = 0; i < pos.length; i += 3) {
    min = Math.min(min, pos[i + 1]);
    max = Math.max(max, pos[i + 1]);
  }

  const range = max - min || 1;

  for (let i = 0; i < pos.length; i += 3) {
    const t = (pos[i + 1] - min) / range;
    const c = heightToColor(t);
    col.set([c.r, c.g, c.b], i);
  }

  geo.attributes.color.needsUpdate = true;
}

/* ============================================================
      CREATE SURFACE
============================================================ */
function createSurface(clippedLeft = false) {
  const seg = Math.round(params.segments);

  const geo = new THREE.PlaneGeometry(params.width, params.height, seg, seg);
  geo.rotateX(-Math.PI / 2);

  const colors = new Float32Array(geo.attributes.position.count * 3);
  geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const clip = clippedLeft ? [new THREE.Plane(new THREE.Vector3(1, 0, 0), 0)] : [];

  applyWaveToGeometry(geo, savedTime * params.speed);
  applyColorToGeometry(geo);

  surface = new THREE.Mesh(
    geo,
    new THREE.MeshPhongMaterial({
      vertexColors: true,
      shininess: 45,
      clippingPlanes: clip,
      side: THREE.DoubleSide,
    })
  );
  scene.add(surface);

  if (params.wireframe) {
    wireframeMesh = new THREE.LineSegments(
      new THREE.WireframeGeometry(geo),
      new THREE.LineBasicMaterial({ color: 0x222222, clippingPlanes: clip })
    );
    scene.add(wireframeMesh);
  }
}

/* ============================================================
      CREATE PARTICLES
============================================================ */
function createParticles(clippedRight = false) {
  const count = params.particleCount;
  const pos = new Float32Array(count * 3);
  const col = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    pos[i3] = (Math.random() - 0.5) * params.width;
    pos[i3 + 1] = 0;
    pos[i3 + 2] = (Math.random() - 0.5) * params.height;

    const c = new THREE.Color().setHSL(Math.random(), 0.6, 0.55);
    col.set([c.r, c.g, c.b], i3);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

  applyWaveToGeometry(geo, savedTime * params.speed);

  const clip = clippedRight ? [new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0)] : [];

  particles = new THREE.Points(
    geo,
    new THREE.PointsMaterial({
      size: params.particleSize,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      alphaMap: particleTexture,
      clippingPlanes: clip,
    })
  );
  scene.add(particles);
}

/* ============================================================
      CREATE HALF-HALF MODE
============================================================ */
function createHalfMode() {
  clearScene();
  const t = savedTime * params.speed;

  /* LEFT = SURFACE */
  createSurface(true);

  /* RIGHT = PARTICLES */
  createParticles(true);
}

/* ============================================================
      REBUILD LOGIC
============================================================ */
function rebuild() {
  if (params.mode === "particles") createParticles(false);
  else if (params.mode === "surface") createSurface(false);
  else if (params.mode === "half-half") createHalfMode();
}

/* ============================================================
      GUI PANEL  (ORDER FIXED AS REQUESTED)
============================================================ */
const gui = new dat.GUI({ width: 300 });
gui.close();

/* Play/Pause */
playPauseController = gui.add(params, "playPause").name("‚è∏ Pause");

/* Display Mode */
gui.add(params, "mode", ["particles", "surface", "half-half"])
   .name("Display Mode")
   .onChange(rebuild);

/* ‚≠ê WAVE CONTROLS MOVED TO THE TOP */
const waveFolder = gui.addFolder("‚öôÔ∏è Wave Controls");
waveFolder.add(params, "amplitude", 0, 3, 0.01).name("Wave Height").onChange(rebuild);
waveFolder.add(params, "frequency", 0, 6, 0.01).name("Frequency").onChange(rebuild);
waveFolder.add(params, "speed", 0, 3, 0.01).name("Speed");
waveFolder.close();

/* Particle Settings */
const particleFolder = gui.addFolder("‚ú® Particle Settings");
particleFolder.add(params, "particleCount", 1000, 50000, 1000).name("Count").onChange(rebuild);
particleFolder.add(params, "particleSize", 0.01, 0.5, 0.01).name("Size");
particleFolder.close();

/* Surface Settings */
const surfaceFolder = gui.addFolder("üåä Surface Settings");
surfaceFolder.add(params, "segments", 4, 300, 1).name("Resolution").onChange(rebuild);
surfaceFolder.add(params, "wireframe").name("Wireframe").onChange(rebuild);
surfaceFolder.close();

/* Load default wave */
rebuild();

/* ============================================================
      ANIMATION LOOP
============================================================ */
function animate() {
  requestAnimationFrame(animate);

  if (!paused) savedTime += clock.getDelta();
  const t = savedTime * params.speed;

  /* Update surface */
  if (surface && !paused) {
    applyWaveToGeometry(surface.geometry, t);
    applyColorToGeometry(surface.geometry);

    if (wireframeMesh) {
      wireframeMesh.geometry.dispose();
      wireframeMesh.geometry = new THREE.WireframeGeometry(surface.geometry);
    }
  }

  /* Update particles */
  if (particles && !paused) {
    applyWaveToGeometry(particles.geometry, t);
  }

  /* Update Half-Half */
  if (params.mode === "half-half" && !paused) {
    if (halfSurface) {
      applyWaveToGeometry(halfSurface.geometry, t);
      applyColorToGeometry(halfSurface.geometry);
    }
    if (halfParticles) applyWaveToGeometry(halfParticles.geometry, t);

    if (halfWireframe) {
      halfWireframe.geometry.dispose();
      halfWireframe.geometry = new THREE.WireframeGeometry(halfSurface.geometry);
    }
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ============================================================
      RESIZE HANDLING
============================================================ */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
