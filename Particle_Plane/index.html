<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Half-Half Wave</title>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000; 
      transition: background 0.3s ease;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* TEXT-ONLY BUTTON */
    #toggle-theme {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 22px;
      font-weight: 600;
      background: none;
      border: none;
      cursor: pointer;
      z-index: 10;
      padding: 5px;
      color: white; /* default in dark mode */
    }
    #toggle-theme:focus { outline: none; }
  </style>
</head>

<body>
  <button id="toggle-theme">Light Mode</button>
  <canvas id="canvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let isDark = true;

    const scene = new THREE.Scene();
    const canvas = document.getElementById("canvas");

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(-10, 5, 10);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.localClippingEnabled = true;
    renderer.setClearColor(0x000000);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(6, 8, 6);
    scene.add(dir);

    const particleTexture = new THREE.TextureLoader().load(
      "https://threejs.org/examples/textures/sprites/disc.png"
    );

    /* ---- WAVE SETTINGS ---- */
    const amp = 1.2;
    const freq = 1.5;
    const speed = 1.2;
    const width = 14;
    const height = 14;
    const segments = 140;
    const particleCount = 20000;
    const particleSize = 0.12;

    let halfSurface, halfWireframe, halfParticles;
    const clock = new THREE.Clock();

    function applyWave(geo, t) {
      const pos = geo.attributes.position.array;
      const yOffset = 1.2;
      for (let i = 0; i < pos.length; i += 3) {
        const x = pos[i];
        const z = pos[i + 2];
        pos[i + 1] =
          Math.sin((x * 0.5 + t) * freq) *
          Math.cos((z * 0.5 + t) * freq) *
          amp +
          yOffset;
      }
      geo.attributes.position.needsUpdate = true;
    }

    function heightColor(t) {
      t = Math.min(Math.max(t, 0), 1);
      const c = new THREE.Color();
      if (t < 0.33) c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
      else if (t < 0.66) {
        const tt = (t - 0.33) / 0.33;
        c.setRGB(tt * 0.4, 0.9, tt * 0.6);
      } else {
        const tt = (t - 0.66) / 0.34;
        c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
      }
      return c;
    }

    function colorize(geo) {
      const pos = geo.attributes.position.array;
      const col = geo.attributes.color.array;
      let min = Infinity, max = -Infinity;

      for (let i = 0; i < pos.length; i += 3) {
        min = Math.min(min, pos[i + 1]);
        max = Math.max(max, pos[i + 1]);
      }

      const range = max - min || 1;

      for (let i = 0; i < pos.length; i += 3) {
        const t = (pos[i + 1] - min) / range;
        const c = heightColor(t);
        col[i] = c.r;
        col[i + 1] = c.g;
        col[i + 2] = c.b;
      }
      col.needsUpdate = true;
    }

    let originalParticleColors;

    function createHalfWave() {
      const geo = new THREE.PlaneBufferGeometry(width, height, segments, segments);
      geo.rotateX(-Math.PI / 2);

      const colors = new Float32Array(geo.attributes.position.count * 3);
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const t = clock.getElapsedTime() * speed;
      applyWave(geo, t);
      colorize(geo);

      const leftClip = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);

      halfSurface = new THREE.Mesh(
        geo,
        new THREE.MeshPhongMaterial({
          vertexColors: true,
          side: THREE.DoubleSide,
          clippingPlanes: [leftClip]
        })
      );
      scene.add(halfSurface);

      /* ALWAYS BLACK WIREFRAME */
      halfWireframe = new THREE.LineSegments(
        new THREE.WireframeGeometry(geo),
        new THREE.LineBasicMaterial({
          color: 0x000000,
          clippingPlanes: [leftClip]
        })
      );
      scene.add(halfWireframe);

      /* PARTICLES */
      const pGeo = new THREE.BufferGeometry();
      const pos = new Float32Array(particleCount * 3);
      const col = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const j = i * 3;
        pos[j] = (Math.random() - 0.5) * width;
        pos[j + 1] = 0;
        pos[j + 2] = (Math.random() - 0.5) * height;

        const c = new THREE.Color().setHSL(Math.random(), 0.6, 0.55);
        col[j] = c.r;
        col[j + 1] = c.g;
        col[j + 2] = c.b;
      }

      originalParticleColors = col.slice();

      pGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      pGeo.setAttribute("color", new THREE.BufferAttribute(col, 3));

      applyWave(pGeo, t);

      const rightClip = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0);

      halfParticles = new THREE.Points(
        pGeo,
        new THREE.PointsMaterial({
          size: particleSize,
          vertexColors: true,
          alphaMap: particleTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          clippingPlanes: [rightClip]
        })
      );

      scene.add(halfParticles);
    }

    createHalfWave();

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime() * speed;

      applyWave(halfSurface.geometry, t);
      colorize(halfSurface.geometry);

      halfWireframe.geometry.dispose();
      halfWireframe.geometry = new THREE.WireframeGeometry(halfSurface.geometry);

      applyWave(halfParticles.geometry, t);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /* ---- THEME TOGGLE ---- */
    const toggleBtn = document.getElementById("toggle-theme");

    toggleBtn.onclick = () => {
      isDark = !isDark;

      const colAttr = halfParticles.geometry.attributes.color.array;

      if (isDark) {
        document.body.style.background = "#000";
        renderer.setClearColor(0x000000);
        toggleBtn.textContent = "Light Mode";
        toggleBtn.style.color = "white";

        // restore colorful particles
        for (let i = 0; i < colAttr.length; i++) {
          colAttr[i] = originalParticleColors[i];
        }
        colAttr.needsUpdate = true;

      } else {
        document.body.style.background = "#fff";
        renderer.setClearColor(0xffffff);
        toggleBtn.textContent = "Dark Mode";
        toggleBtn.style.color = "black";

        // particles â†’ very dark black
        for (let i = 0; i < colAttr.length; i += 3) {
          colAttr[i] = 0.02;   /* deep black */
          colAttr[i + 1] = 0.02;
          colAttr[i + 2] = 0.02;
        }
        colAttr.needsUpdate = true;
      }
    };
  </script>
</body>
</html>
