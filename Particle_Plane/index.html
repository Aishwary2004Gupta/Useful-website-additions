<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle / Surface Animation</title>
    <style>
      html, body {
        overflow: hidden;
        height: 100%;
        background: #00000015;
        margin: 0;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .dg {
        z-index: 99999 !important;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
      // Scene
      const scene = new THREE.Scene();
      const canvas = document.querySelector("#canvas");

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 2.5, 7);

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const clock = new THREE.Clock();

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 10);
      scene.add(ambient, dir);

      const textureLoader = new THREE.TextureLoader();
      const particleTexture = textureLoader.load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      let points = null;
      let surface = null;
      let wireframeMesh = null;

      // UI PARAMS
      const params = {
        mode: "particles",
        particleCount: 20000,
        particleSize: 0.12,
        segments: 120,
        width: 12,
        height: 12,
        amplitude: 1.1,
        frequency: 1.5,
        speed: 1.0,
        wireframe: true,
        colorMap: "height",

        applyParticleDefaults() {
          params.particleSize = 0.12;
          params.particleCount = 20000;
        },

        applySurfaceDefaults() {
          params.segments = 140;
          params.width = 12;
          params.height = 12;
          params.wireframe = true;
          params.colorMap = "coolwarm";
        }
      };

      // Height -> Color
      function heightToColor(t, scheme) {
        if (scheme === "coolwarm") {
          return new THREE.Color(t, 0.5, 1 - t);
        }
        return new THREE.Color(t, 0.3 + t * 0.7, 1 - t);
      }

      function disposeObjects() {
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        if (surface) {
          scene.remove(surface);
          surface.geometry.dispose();
          surface.material.dispose();
          surface = null;
        }
        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMesh.geometry.dispose();
          wireframeMesh.material.dispose();
          wireframeMesh = null;
        }
      }

      function createParticles() {
        disposeObjects();
        params.applyParticleDefaults();

        const count = params.particleCount;
        const positions = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          positions[i3] = (Math.random() - 0.5) * params.width;
          positions[i3 + 1] = 0;
          positions[i3 + 2] = (Math.random() - 0.5) * params.height;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
          size: params.particleSize,
          alphaMap: particleTexture,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          color: 0xffffff
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      function createSurface() {
        disposeObjects();
        params.applySurfaceDefaults();

        const geo = new THREE.PlaneBufferGeometry(
          params.width,
          params.height,
          params.segments,
          params.segments
        );
        geo.rotateX(-Math.PI / 2);

        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          flatShading: false,
          side: THREE.DoubleSide,
          shininess: 40
        });

        surface = new THREE.Mesh(geo, material);
        scene.add(surface);

        if (params.wireframe) {
          wireframeMesh = new THREE.LineSegments(
            new THREE.WireframeGeometry(geo),
            new THREE.LineBasicMaterial({ color: 0x111111 })
          );
          scene.add(wireframeMesh);
        }
      }

      function rebuild() {
        if (params.mode === "particles") {
          createParticles();
        } else {
          createSurface();
        }
      }

      // GUI
      const gui = new dat.GUI({ width: 300, closed: true });

      gui.add(params, "mode", ["particles", "surface"])
        .name("Display Mode")
        .onChange(rebuild);

      const pf = gui.addFolder("âœ¨ Particles");
      pf.add(params, "particleCount", 1000, 50000, 1000).name("Count")
        .onFinishChange(() => params.mode === "particles" && rebuild());
      pf.add(params, "particleSize", 0.01, 0.5, 0.01).name("Size")
        .onChange(() => points && (points.material.size = params.particleSize));
      pf.close();

      const sf = gui.addFolder("ðŸŒŠ Surface");
      sf.add(params, "segments", 10, 300, 1).name("Detail")
        .onFinishChange(rebuild);
      sf.add(params, "width", 4, 30, 0.1).name("Width")
        .onFinishChange(rebuild);
      sf.add(params, "height", 4, 30, 0.1).name("Depth")
        .onFinishChange(rebuild);
      sf.add(params, "wireframe").name("Wireframe")
        .onChange(rebuild);
      sf.add(params, "colorMap", ["height", "coolwarm"])
        .name("Color")
        .onChange(rebuild);
      sf.close();

      const wf = gui.addFolder("ðŸŽ› Waves");
      wf.add(params, "amplitude", 0, 3, 0.01).name("Height");
      wf.add(params, "frequency", 0, 6, 0.01).name("Frequency");
      wf.add(params, "speed", 0, 3, 0.01).name("Speed");
      wf.close();

      rebuild();

      function animate() {
        const t = clock.getElapsedTime() * params.speed;

        if (points) {
          const pos = points.geometry.attributes.position.array;
          for (let i = 0; i < pos.length; i += 3) {
            const x = pos[i];
            const z = pos[i + 2];
            pos[i + 1] =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
          }
          points.geometry.attributes.position.needsUpdate = true;
        }

        if (surface) {
          const pos = surface.geometry.attributes.position.array;
          const col = new Float32Array(pos.length);
          let min = Infinity, max = -Infinity;

          for (let i = 0; i < pos.length; i += 3) {
            const x = pos[i];
            const z = pos[i + 2];
            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
            pos[i + 1] = y;
            min = Math.min(min, y);
            max = Math.max(max, y);
          }

          const range = max - min;
          for (let i = 0; i < pos.length; i += 3) {
            const tcol = (pos[i + 1] - min) / range;
            const c = heightToColor(tcol, params.colorMap);
            col[i] = c.r;
            col[i + 1] = c.g;
            col[i + 2] = c.b;
          }

          surface.geometry.setAttribute("color", new THREE.BufferAttribute(col, 3));
          surface.geometry.attributes.position.needsUpdate = true;
          surface.geometry.attributes.color.needsUpdate = true;
          surface.geometry.computeVertexNormals();

          if (wireframeMesh) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(surface.geometry);
          }
        }

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
