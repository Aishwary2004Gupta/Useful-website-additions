<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grid Distortion (Color Image)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    .distortion-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div class="distortion-container" id="container"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.157.0/three.min.js"></script>
  <script>
    // Grab DOM
    const container = document.getElementById('container');

    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1000, 1000);
    camera.position.z = 2;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Uniforms
    const uniforms = {
      time: { value: 0 },
      resolution: { value: new THREE.Vector4(container.clientWidth, container.clientHeight, 1, 1) },
      uTexture: { value: null },
      uDataTexture: { value: null }
    };

    // Vertex Shader
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    // Fragment Shader
    const fragmentShader = `
      uniform sampler2D uDataTexture;
      uniform sampler2D uTexture;
      varying vec2 vUv;
      void main() {
        vec2 uv = vUv;
        vec4 offset = texture2D(uDataTexture, vUv);
        gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);
      }
    `;

    // Load a colored placeholder image (no grayscale)
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('https://picsum.photos/1920/1080', (texture) => {
      texture.minFilter = THREE.LinearFilter;
      uniforms.uTexture.value = texture;
      initPlane();
    });

    // Create the data texture for distortion
    const gridSize = 10, relaxation = 0.9, mouseInfluence = 0.1, strength = 0.15;
    const data = new Float32Array(4 * gridSize * gridSize);
    for (let i = 0; i < gridSize * gridSize; i++) {
      data[i * 4] = Math.random() * 255 - 125;
      data[i * 4 + 1] = Math.random() * 255 - 125;
    }
    const dataTexture = new THREE.DataTexture(data, gridSize, gridSize, THREE.RGBAFormat, THREE.FloatType);
    dataTexture.needsUpdate = true;
    uniforms.uDataTexture.value = dataTexture;

    let plane;
    function initPlane() {
      const geometry = new THREE.PlaneGeometry(1, 1, gridSize - 1, gridSize - 1);
      const material = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        uniforms,
        vertexShader,
        fragmentShader
      });
      plane = new THREE.Mesh(geometry, material);
      scene.add(plane);
      animate();
    }

    // Mouse tracking
    const mouse = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 };
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = 1 - (e.clientY - rect.top) / rect.height;
      mouse.vX = x - mouse.prevX;
      mouse.vY = y - mouse.prevY;
      Object.assign(mouse, { x, y, prevX: x, prevY: y });
    });

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      uniforms.time.value += 0.05;

      const d = dataTexture.image.data;
      for (let i = 0; i < gridSize * gridSize; i++) {
        d[i * 4] *= relaxation;
        d[i * 4 + 1] *= relaxation;
      }

      const gridMouseX = gridSize * mouse.x;
      const gridMouseY = gridSize * mouse.y;
      const maxDist = gridSize * mouseInfluence;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const dist = (gridMouseX - i)**2 + (gridMouseY - j)**2;
          if (dist < maxDist * maxDist) {
            const idx = 4 * (i + gridSize * j);
            const power = Math.min(maxDist / Math.sqrt(dist), 10);
            d[idx] += strength * 100 * mouse.vX * power;
            d[idx + 1] -= strength * 100 * mouse.vY * power;
          }
        }
      }

      dataTexture.needsUpdate = true;
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
