<!-- Create by @aish2004gupta on X -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wave Animation</title>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #00000015;
    }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .dg {
      z-index: 99999 !important;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    const canvas = document.getElementById("canvas");

    const camera = new THREE.PerspectiveCamera(
      65,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(-10, 5, 10);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const clock = new THREE.Clock();

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(6, 8, 6);
    scene.add(dirLight);

    const particleTexture = new THREE.TextureLoader().load(
      "https://threejs.org/examples/textures/sprites/disc.png"
    );

    // PARAMETERS
    const params = {
      mode: "particles",
      amplitude: 1.2,
      frequency: 1.5,
      speed: 1.2,
      play: true,
      targetSpeed: 1.2,
      particleCount: 20000,
      particleSize: 0.12,
      width: 14,
      height: 14,
      segments: 140,
      wireframe: true,
      colorMap: "height",
    };

    let currentSpeed = params.speed;
    let points, surface, wireframeMesh;

    function togglePlay(button) {
      params.play = !params.play;
      params.targetSpeed = params.play ? params.speed : 0;
      button.name(params.play ? "‚è∏ Pause Wave" : "‚ñ∂Ô∏è Play Wave");
    }

    function disposeObjects() {
      if (points) { scene.remove(points); points.geometry.dispose(); points.material.dispose(); points = null; }
      if (surface) { scene.remove(surface); surface.geometry.dispose(); surface.material.dispose(); surface = null; }
      if (wireframeMesh) { scene.remove(wireframeMesh); wireframeMesh.geometry.dispose(); wireframeMesh.material.dispose(); wireframeMesh = null; }
    }

    function heightToColor(t) {
      t = THREE.MathUtils.clamp(t, 0, 1);
      const c = new THREE.Color();
      if (t < 0.33) c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
      else if (t < 0.66) {
        const tt = (t - 0.33) / 0.33;
        c.setRGB(tt * 0.4, 0.9, tt * 0.6);
      } else {
        const tt = (t - 0.66) / 0.34;
        c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
      }
      return c;
    }

    function createParticles() {
      disposeObjects();
      const count = Math.max(1000, Math.min(50000, params.particleCount));
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * params.width;
        positions[i3 + 1] = 0;
        positions[i3 + 2] = (Math.random() - 0.5) * params.height;

        const c = new THREE.Color().setHSL(Math.random(), 0.6, 0.55);
        colors.set([c.r, c.g, c.b], i3);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      points = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: params.particleSize,
          vertexColors: true,
          alphaMap: particleTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
        })
      );
      scene.add(points);
    }

    function createSurface() {
      disposeObjects();
      const seg = Math.max(4, params.segments);
      const geometry = new THREE.PlaneBufferGeometry(
        params.width, params.height, seg, seg
      );
      geometry.rotateX(-Math.PI / 2);

      const colors = new Float32Array(geometry.attributes.position.count * 3);
      colors.fill(0.5);
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      surface = new THREE.Mesh(
        geometry,
        new THREE.MeshPhongMaterial({ vertexColors: true, shininess: 45, side: THREE.DoubleSide })
      );
      scene.add(surface);

      if (params.wireframe) {
        wireframeMesh = new THREE.LineSegments(
          new THREE.WireframeGeometry(geometry),
          new THREE.LineBasicMaterial({ color: 0x101010 })
        );
        scene.add(wireframeMesh);
      }
    }

    function rebuild() {
      params.mode === "particles" ? createParticles() : createSurface();
    }

    const gui = new dat.GUI({ width: 300 });
    gui.close();

    gui.add(params, "mode", ["particles", "surface"])
      .name("Display Mode üåì")
      .onChange(() => { rebuild(); });

    const wavesFolder = gui.addFolder("üéõ Wave Controls");
    wavesFolder.add(params, "amplitude", 0, 3, 0.01).name("Wave Height");
    wavesFolder.add(params, "frequency", 0, 6, 0.01).name("Frequency");
    wavesFolder.add(params, "speed", 0, 3, 0.01).name("Speed")
      .onChange((v) => params.targetSpeed = v);

    let playController = wavesFolder
      .add({ run: () => togglePlay(playController) }, "run")
      .name("‚è∏ Pause Wave");

    wavesFolder.close();

    rebuild();

    function animate() {
      const elapsed = clock.getElapsedTime();

      // Smooth speed transition
      currentSpeed += (params.targetSpeed - currentSpeed) * 0.05;
      const t = elapsed * currentSpeed;

      if (points) {
        const pos = points.geometry.attributes.position.array;
        for (let i = 0; i < pos.length; i += 3) {
          const x = pos[i], z = pos[i + 2];
          pos[i + 1] = Math.sin((x * 0.5 + t) * params.frequency) *
                       Math.cos((z * 0.5 + t) * params.frequency) *
                       params.amplitude;
        }
        points.geometry.attributes.position.needsUpdate = true;
      }

      if (surface) {
        const pos = surface.geometry.attributes.position.array;
        for (let i = 0; i < pos.length; i += 3) {
          const x = pos[i], z = pos[i + 2];
          pos[i + 1] = Math.sin((x * 0.5 + t) * params.frequency) *
                       Math.cos((z * 0.5 + t) * params.frequency) *
                       params.amplitude;
        }
        surface.geometry.attributes.position.needsUpdate = true;
      }

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>
</html>
