<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Depixelation Effect</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: sans-serif;
        overflow: hidden;
      }

      .viewer {
        position: relative;
        background: #111;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
        display: inline-block;
        max-width: 100vw;
        max-height: 100vh;
      }

      canvas {
        display: block;
      }

      #ui {
        position: absolute;
        bottom: 16px;
        left: 16px;
        right: 16px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.65);
        padding: 10px;
        border-radius: 12px;
        color: white;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 12px;
      }

      #controls {
        display: flex;
        gap: 6px;
      }

      #controls input[type="text"] {
        flex: 1;
        padding: 6px;
        border-radius: 6px;
        border: none;
        outline: none;
      }

      #controls button,
      #controls input[type="file"] {
        background: #74b7ff;
        border: none;
        color: #000;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }

      #progress {
        width: 100%;
        height: 4px;
        -webkit-appearance: none;
        background: #444;
        border-radius: 2px;
        outline: none;
      }

      #progress::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #74b7ff;
        cursor: pointer;
      }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div class="viewer" id="viewer">
      <div id="ui">
        <div id="controls">
          <input id="imgUrl" type="text" placeholder="Paste image URLâ€¦" />
          <button id="loadUrl">Load</button>
          <input id="fileInput" type="file" accept="image/*" />
        </div>

        <label>Progress</label>
        <input id="progress" type="range" min="0" max="1" step="0.001" value="0" />
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

      const container = document.getElementById("viewer");

      /* ---------------- SHADER ---------------- */
      const DepixelShader = {
        uniforms: {
          tDiffuse: { value: null },
          progress: { value: 0 },
          resolution: { value: new THREE.Vector2() },
          time: { value: 0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform sampler2D tDiffuse;
          uniform float progress;
          uniform vec2 resolution;
          uniform float time;
          varying vec2 vUv;

          float random(vec2 st){
            return fract(sin(dot(st,vec2(12.9898,78.233)))*43758.5453123);
          }

          const float LEVELS = 5.0;

          void main(){
            vec2 uv = vUv;
            float baseSize = pow(2.0, LEVELS);
            float lf = progress * LEVELS;
            float cl = floor(lf);
            float f = fract(lf);

            float sizeA = baseSize / pow(2.0, cl);
            float sizeB = max(sizeA / 2.0, 1.0);
            float size = mix(sizeA, sizeB, f);

            vec2 pix = size / resolution;
            vec2 snapUv = pix * floor(uv / pix);

            vec4 c1 = texture2D(tDiffuse, snapUv);
            vec4 c2 = texture2D(tDiffuse, uv);

            float blend = smoothstep(0.95,1.0,progress);
            gl_FragColor = mix(c1,c2,blend);
          }
        `
      };

      /* ---------------- RENDER ---------------- */
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera();
      camera.position.z = 10;

      let plane, texture;

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const shaderPass = new ShaderPass(DepixelShader);
      composer.addPass(shaderPass);

      function resizeToImage(img) {
        const padding = 40;
        const maxW = innerWidth - padding;
        const maxH = innerHeight - padding;
        const scale = Math.min(maxW / img.width, maxH / img.height, 1);

        const w = img.width * scale;
        const h = img.height * scale;

        container.style.width = w + "px";
        container.style.height = h + "px";

        renderer.setSize(w, h, false);
        composer.setSize(w, h);
        shaderPass.uniforms.resolution.value.set(w, h);

        camera.left = -w / 2;
        camera.right = w / 2;
        camera.top = h / 2;
        camera.bottom = -h / 2;
        camera.updateProjectionMatrix();

        plane.scale.set(w, h, 1);
      }

      function loadImage(src) {
        new THREE.TextureLoader().load(src, tex => {
          if (texture) texture.dispose();
          texture = tex;
          texture.colorSpace = THREE.SRGBColorSpace;

          if (!plane) {
            plane = new THREE.Mesh(
              new THREE.PlaneGeometry(1, 1),
              new THREE.MeshBasicMaterial({ map: texture })
            );
            scene.add(plane);
          } else {
            plane.material.map = texture;
            plane.material.needsUpdate = true;
          }

          resizeToImage(texture.image);
        });
      }

      loadImage("https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg");

      /* ---------------- UI ---------------- */
      document.getElementById("loadUrl").onclick = () => {
        const url = imgUrl.value.trim();
        if (url) loadImage(url);
      };

      fileInput.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        loadImage(url);
      };

      /* ---------------- ANIMATE ---------------- */
      const slider = document.getElementById("progress");
      let smooth = 0;

      function animate(t) {
        requestAnimationFrame(animate);
        smooth += (slider.value - smooth) * 0.08;
        shaderPass.uniforms.progress.value = smooth;
        shaderPass.uniforms.time.value = t * 0.001;
        composer.render();
      }

      animate(0);
    </script>
  </body>
</html>
  