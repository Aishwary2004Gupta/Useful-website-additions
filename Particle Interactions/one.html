<!doctype html>
<html>
  <head>
    <style>
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0);
      }
    </style>

    <title>Particle Name</title>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let particles = [];
      const mouse = { x: null, y: null };

      // Store text info for shadow
      let textInfo = {
        text1: "Let's",
        text2: "Connect üôãüèª‚Äç‚ôÇÔ∏è",
        fontSize: 80,
        x: 0,
        y: 0,
      };

      // Set canvas size
      function initCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      // Create particles from text
      function createTextParticles() {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");

        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;

        // BIGGER Text styling - increased from /15 to /8 and min from 80 to 150
        const fontSize = Math.min(window.innerWidth / 6, 180);
        textInfo.fontSize = fontSize;

        tempCtx.font = `bold ${fontSize}px "Arial Black", Arial, sans-serif`;
        tempCtx.fillStyle = "white";
        tempCtx.textBaseline = "middle";
        tempCtx.textAlign = "center";

        // Calculate positions
        const x = canvas.width / 2;
        const y = canvas.height / 2;

        // Store for shadow drawing
        textInfo.x = x;
        textInfo.y = y;

        // Draw text
        tempCtx.fillText(textInfo.text1, x, y - fontSize * 0.7);
        tempCtx.fillText(textInfo.text2, x, y + fontSize * 0.7);

        // Create particles from text pixels
        const imageData = tempCtx.getImageData(
          0,
          0,
          tempCanvas.width,
          tempCanvas.height,
        );
        const data = imageData.data;
        particles = [];

        // Adjust spacing based on font size for consistent density
        const spacing = Math.max(2, Math.floor(fontSize / 50));

        for (let y = 0; y < tempCanvas.height; y += spacing) {
          for (let x = 0; x < tempCanvas.width; x += spacing) {
            const index = (y * tempCanvas.width + x) * 4;
            if (data[index + 3] > 128) {
              particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                originX: x,
                originY: y,
                size: Math.max(1, spacing / 2), // Scale particle size with spacing
                vx: 0,
                vy: 0,
                friction: Math.random() * 0.01 + 0.95,
                ease: Math.random() * 0.1 + 0.02,
              });
            }
          }
        }
      }

      // Draw the shadow/ghost text behind particles
      function drawShadowText() {
        const fontSize = textInfo.fontSize;
        const x = textInfo.x;
        const y = textInfo.y;

        ctx.save();

        // Shadow text styling - subtle but readable
        ctx.font = `bold ${fontSize}px "Arial Black", Arial, sans-serif`;
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";

        // Option 1: Solid dark shadow with slight transparency
        ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
        ctx.fillText(textInfo.text1, x, y - fontSize * 0.7);
        ctx.fillText(textInfo.text2, x, y + fontSize * 0.7);

        // Option 2: Add stroke/outline for better visibility
        ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
        ctx.lineWidth = 1;
        ctx.strokeText(textInfo.text1, x, y - fontSize * 0.7);
        ctx.strokeText(textInfo.text2, x, y + fontSize * 0.7);

        ctx.restore();
      }

      function animate() {
        // Clear with dark background
        ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw shadow text FIRST (behind particles)
        drawShadowText();

        particles.forEach((particle) => {
          // Mouse interaction
          const dx = mouse.x - particle.x;
          const dy = mouse.y - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Increased interaction radius for bigger text
          const interactionRadius = 150;

          if (distance < interactionRadius) {
            const force = (interactionRadius - distance) / interactionRadius;
            const angle = Math.atan2(dy, dx);
            particle.vx -= Math.cos(angle) * force * 6;
            particle.vy -= Math.sin(angle) * force * 6;
          }

          // Return to position
          const tx = particle.originX - particle.x;
          const ty = particle.originY - particle.y;
          const dist = Math.sqrt(tx * tx + ty * ty);
          const angle = Math.atan2(ty, tx);
          const force = dist * 0.01;

          particle.vx += Math.cos(angle) * force;
          particle.vy += Math.sin(angle) * force;
          particle.vx *= particle.friction;
          particle.vy *= particle.friction;
          particle.x += particle.vx;
          particle.y += particle.vy;

          // Draw particle with glow effect
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);

          // Brighter particles
          const alpha = Math.min(1, 1 - dist / 150);
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.fill();
        });

        requestAnimationFrame(animate);
      }

      // Event listeners
      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      // Touch support
      window.addEventListener("touchmove", (e) => {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      });

      window.addEventListener("resize", () => {
        initCanvas();
        createTextParticles();
      });

      // Initialize
      initCanvas();
      createTextParticles();
      animate();
    </script>
  </body>
</html>
