<!DOCTYPE html>
<html>
<head>
    <title>Interactive Particles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 1;
            color: white;
            padding: 2rem;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>SHE WAITS IN THE RESTLESS HORIZON</h1>
        <p>An Immersive Digital Experience</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ParticleSystem {
            constructor() {
                this.init();
                this.createParticles();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                // Mouse properties
                this.mouse = new THREE.Vector2(0, 0);
                this.target = new THREE.Vector2(0, 0);
                this.radius = 100;
                this.strength = 0.1;

                // Particle properties
                this.particleCount = 10000;
                this.particles = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.particleCount * 3);
                this.velocities = new Float32Array(this.particleCount * 3);
            }

            createParticles() {
                // Initialize particle positions and velocities
                for(let i = 0; i < this.particleCount; i++) {
                    this.positions[i*3] = (Math.random() - 0.5) * 100;
                    this.positions[i*3+1] = (Math.random() - 0.5) * 100;
                    this.positions[i*3+2] = (Math.random() - 0.5) * 100;
                    
                    this.velocities[i*3] = 0;
                    this.velocities[i*3+1] = 0;
                    this.velocities[i*3+2] = 0;
                }

                // Set geometry attributes
                this.particles.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.particles.setAttribute('velocity', new THREE.BufferAttribute(this.velocities, 3));

                // Create particle material
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false
                });

                // Create particle system
                this.particleSystem = new THREE.Points(this.particles, material);
                this.scene.add(this.particleSystem);

                this.camera.position.z = 50;
            }

            setupEventListeners() {
                // Mouse movement
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });

                // Touch movement
                window.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                }, { passive: false });

                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            updateParticles() {
                const positions = this.particleSystem.geometry.attributes.position.array;
                const velocities = this.particleSystem.geometry.attributes.velocity.array;
                
                // Convert mouse to 3D space
                const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
                vector.unproject(this.camera);
                const mousePoint = new THREE.Vector3().copy(vector);

                for(let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i+1];
                    const z = positions[i+2];

                    // Calculate distance to mouse
                    const dx = mousePoint.x - x;
                    const dy = mousePoint.y - y;
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    // Mouse interaction force
                    if(distance < this.radius) {
                        const force = (this.radius - distance) / this.radius;
                        velocities[i] += dx * force * this.strength;
                        velocities[i+1] += dy * force * this.strength;
                    }

                    // Apply velocity damping
                    velocities[i] *= 0.95;
                    velocities[i+1] *= 0.95;

                    // Update positions
                    positions[i] += velocities[i];
                    positions[i+1] += velocities[i+1];
                }

                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateParticles();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize particle system
        new ParticleSystem();
    </script>
</body>
</html>