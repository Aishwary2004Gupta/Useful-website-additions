<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ring Mesh â€” Optimized Version</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #1a1a1a;
        font-family: Arial, sans-serif;
        transition: background 0.3s ease;
      }
      canvas {
        display: block;
      }
      #toggleBtn {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 16px;
        background: transparent;
        color: #fff;
        border: none;
        cursor: pointer;
        z-index: 100;
        font-weight: bold;
      }
      #toggleBtn:hover {
        transform: scale(1.05);
        opacity: 0.75;
      }
      body.light-mode {
        background: #efefef;
      }
      body.light-mode #toggleBtn {
        color: #000;
      }
    </style>
  </head>
  <body>
    <button id="toggleBtn">[ Light ]</button>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      ///////////////////////////////////////////////////////////////////////////
      // SCENE SETUP
      ///////////////////////////////////////////////////////////////////////////
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      const camera = new THREE.PerspectiveCamera(
        80,
        innerWidth / innerHeight,
        0.1,
        3000
      );
      camera.position.set(0, -300, 600);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      let isDarkMode = true;

      ///////////////////////////////////////////////////////////////////////////
      // MATERIALS
      ///////////////////////////////////////////////////////////////////////////
      const faceMat_light = new THREE.MeshBasicMaterial({ color: 0xefefef });
      const frameMat_light = new THREE.LineBasicMaterial({ color: 0x272727 });

      const faceMat_dark = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
      const frameMat_dark = new THREE.LineBasicMaterial({ color: 0xefefef });

      let faceMat = faceMat_dark;
      let frameMat = frameMat_dark;

      ///////////////////////////////////////////////////////////////////////////
      // GROUPS
      ///////////////////////////////////////////////////////////////////////////
      const root = new THREE.Group();
      const innerLoopGroup = new THREE.Group();
      const outerLoopGroup = new THREE.Group();
      root.add(innerLoopGroup, outerLoopGroup);
      scene.add(root);

      ///////////////////////////////////////////////////////////////////////////
      // BUILD RINGS ONCE
      ///////////////////////////////////////////////////////////////////////////
      function createRingMesh(pos, radius, width, height) {
        const geometry = new THREE.TorusGeometry(radius, width / 2, 6, 100);
        const face = new THREE.Mesh(geometry, faceMat);

        const edges = new THREE.EdgesGeometry(geometry);
        const frame = new THREE.LineSegments(edges, frameMat);

        face.position.copy(pos);
        frame.position.copy(pos);

        return { face, frame };
      }

      function buildScene() {
        for (let z = -400; z <= 400; z += 40) {
          const pos = new THREE.Vector3(0, 0, z);

          const inner = createRingMesh(pos, 150, 8, 15);
          innerLoopGroup.add(inner.face, inner.frame);

          const outer = createRingMesh(pos, 300, 8, 15);
          outerLoopGroup.add(outer.face, outer.frame);
        }
      }

      buildScene();

      ///////////////////////////////////////////////////////////////////////////
      // DARK MODE TOGGLE
      ///////////////////////////////////////////////////////////////////////////
      document.getElementById("toggleBtn").addEventListener("click", () => {
        isDarkMode = !isDarkMode;

        if (isDarkMode) {
          document.body.classList.remove("light-mode");
          scene.background.setHex(0x1a1a1a);
          faceMat = faceMat_dark;
          frameMat = frameMat_dark;
          document.getElementById("toggleBtn").textContent = "[ Light ]";
        } else {
          document.body.classList.add("light-mode");
          scene.background.setHex(0xefefef);
          faceMat = faceMat_light;
          frameMat = frameMat_light;
          document.getElementById("toggleBtn").textContent = "[ Dark ]";
        }

        // Update all materials instantly
        innerLoopGroup.children.concat(outerLoopGroup.children).forEach((m) => {
          m.material = m.type === "Mesh" ? faceMat : frameMat;
        });
      });

      ///////////////////////////////////////////////////////////////////////////
      // ANIMATION
      ///////////////////////////////////////////////////////////////////////////
      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;
        
        // Smooth movement
        innerLoopGroup.position.y = Math.sin(time * 2) * 8;
        outerLoopGroup.position.y = -Math.sin(time * 2.5) * 12;

        // Rotations for a cool tunnel effect
        innerLoopGroup.rotation.z += 0.008;
        outerLoopGroup.rotation.z -= 0.010;

        renderer.render(scene, camera);
      }

      animate();

      ///////////////////////////////////////////////////////////////////////////
      // RESIZE
      ///////////////////////////////////////////////////////////////////////////
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
