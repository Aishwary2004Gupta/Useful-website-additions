<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Visual Glass Cube</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 4, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const light = new THREE.PointLight(0xffffff, 20);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));

        // --- 1. The Glass Cube & Outline ---
        const glassGeo = new THREE.BoxGeometry(2, 2, 2);
        const glassMat = new THREE.MeshPhysicalMaterial({
            transmission: 1, thickness: 0.5, ior: 1.5, roughness: 0.05,
            transparent: true, opacity: 0.4, side: THREE.DoubleSide
        });
        const glassCube = new THREE.Mesh(glassGeo, glassMat);
        scene.add(glassCube);

        const edgeGeo = new THREE.EdgesGeometry(glassGeo);
        const edgeLine = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x00ffff }));
        glassCube.add(edgeLine);

        // --- 2. Visual System A: Morphing Blob (Faces X+, X-) ---
        const blobGeo = new THREE.SphereGeometry(0.6, 32, 32);
        const blobMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, wireframe: true });
        const blob = new THREE.Mesh(blobGeo, blobMat);
        scene.add(blob);

        // --- 3. Visual System B: Geometric Star (Faces Y+, Y-) ---
        const starGeo = new THREE.OctahedronGeometry(0.7, 0);
        const starMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, flatShading: true });
        const star = new THREE.Mesh(starGeo, starMat);
        scene.add(star);

        // --- 4. Visual System C: Particle Swarm (Faces Z+, Z-) ---
        const partGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(300 * 3);
        for(let i=0; i<900; i++) pPos[i] = (Math.random() - 0.5) * 1.2;
        partGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const partMat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.03 });
        const particles = new THREE.Points(partGeo, partMat);
        scene.add(particles);

        // --- Interaction ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;

        // --- Animation & Face Tracking ---
        const faceNormals = [
            new THREE.Vector3(1, 0, 0),  // Right
            new THREE.Vector3(-1, 0, 0), // Left
            new THREE.Vector3(0, 1, 0),  // Up
            new THREE.Vector3(0, -1, 0), // Down
            new THREE.Vector3(0, 0, 1),  // Front
            new THREE.Vector3(0, 0, -1)  // Back
        ];

        let time = 0;
        function animate() {
            time += 0.02;
            requestAnimationFrame(animate);

            // Sync rotations
            blob.rotation.y = star.rotation.y = particles.rotation.y = glassCube.rotation.y += 0.005;
            blob.rotation.x = star.rotation.x = particles.rotation.x = glassCube.rotation.x += 0.003;

            // Face Tracking Logic
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir).negate(); // Direction from cube to camera

            // Calculate visibility based on which face normal aligns with camera
            let vA = 0, vB = 0, vC = 0;

            faceNormals.forEach((n, i) => {
                const worldNormal = n.clone().applyQuaternion(glassCube.quaternion);
                const dot = worldNormal.dot(camDir);
                const weight = Math.max(0, dot); // How much this face is "seen"

                if (i < 2) vA += weight;      // Faces 1 & 2
                else if (i < 4) vB += weight; // Faces 3 & 4
                else vC += weight;            // Faces 5 & 6
            });

            // Apply Opacity/Visibility smoothly
            blob.material.opacity = vA;
            blob.visible = vA > 0.1;
            blob.scale.setScalar(1 + Math.sin(time) * 0.2); // Morphing effect

            star.material.opacity = vB;
            star.visible = vB > 0.1;
            star.rotation.z += 0.05;

            particles.material.opacity = vC;
            particles.visible = vC > 0.1;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>