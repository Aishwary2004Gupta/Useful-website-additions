<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle Animation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      html,
      body {
        height: 100%;
      }
      #canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #00000015;
      }
      /* GUI panel style */
      .dg {
        z-index: 9999 !important;
      }
      /* Make GUI more compact */
      .dg.ac {
        right: 0 !important;
        left: auto !important;
      }
      .dg.main .close-button {
        height: 16px !important;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
      // Initialize scene
      const scene = new THREE.Scene();
      const canvas = document.querySelector("#canvas");

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 2.2, 7);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // controls & clock
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      const clock = new THREE.Clock();

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 7);
      scene.add(ambient, dir);

      // GUI params - improved with better defaults and organization
      const params = {
        mode: "particles",
        preset: "default",
        particleCount: 15000,
        particleSize: 0.15,
        segments: 80,
        width: 12,
        height: 12,
        amplitude: 1.2,
        frequency: 1.8,
        speed: 1.2,
        wireframe: true,
        colorMap: "height",
        autoRotate: false,
        rotationSpeed: 0.5,
        // Presets
        applyPresetImageLook() {
          this.mode = "surface";
          this.segments = 120;
          this.width = 14;
          this.height = 14;
          this.amplitude = 1.4;
          this.frequency = 2.0;
          this.speed = 1.0;
          this.wireframe = true;
          this.colorMap = "coolwarm";
          rebuild();
        },
        applyPresetParticles() {
          this.mode = "particles";
          this.particleCount = 25000;
          this.particleSize = 0.08;
          this.amplitude = 1.0;
          this.frequency = 2.2;
          this.speed = 1.5;
          rebuild();
        },
        applyPresetCalm() {
          this.amplitude = 0.6;
          this.frequency = 1.2;
          this.speed = 0.5;
          rebuild();
        }
      };

      // Geometry holders
      let points = null;
      let surface = null;
      let wireframeMesh = null;
      let contourPlane = null;

      const textureLoader = new THREE.TextureLoader();
      // soft disc for points
      const particleTexture = textureLoader.load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      // Helper - create a colors array from heights
      function heightToColor(t, scheme = "height") {
        // t in [0,1]
        if (scheme === "coolwarm") {
          // Cool to warm gradient
          const r = 0.5 + 0.5 * Math.sin(Math.PI * t);
          const g = 0.3 + 0.4 * Math.sin(2 * Math.PI * t);
          const b = 0.5 + 0.5 * Math.cos(Math.PI * t);
          return new THREE.Color(r, g, b);
        }
        if (scheme === "rainbow") {
          // Rainbow gradient
          const hue = t * 0.8; // 0 to 0.8
          return new THREE.Color().setHSL(hue, 0.8, 0.5);
        }
        // default height map: deep blue -> cyan -> green -> yellow -> red
        const c = new THREE.Color();
        if (t < 0.25) {
          const tt = t / 0.25;
          c.setRGB(0, 0.2 * tt, 0.4 + 0.6 * tt);
        } else if (t < 0.5) {
          const tt = (t - 0.25) / 0.25;
          c.setRGB(0, 0.6 + 0.4 * tt, 0.8 - 0.8 * tt);
        } else if (t < 0.75) {
          const tt = (t - 0.5) / 0.25;
          c.setRGB(tt, 0.8, 0);
        } else {
          const tt = (t - 0.75) / 0.25;
          c.setRGB(0.8 + 0.2 * tt, 0.8 - 0.8 * tt, 0);
        }
        return c;
      }

      // Create particles Points
      function createParticles() {
        disposeObjects();
        const count = Math.max(
          1000,
          Math.min(100000, Math.floor(params.particleCount))
        );
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        
        for (let i = 0; i < count; i++) {
          const x = (Math.random() - 0.5) * params.width;
          const z = (Math.random() - 0.5) * params.height;
          const y = 0; // will be animated
          const i3 = i * 3;
          positions[i3] = x;
          positions[i3 + 1] = y;
          positions[i3 + 2] = z;
          // Initial random colors
          const c = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.7, 0.5);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: params.particleSize,
          sizeAttenuation: true,
          transparent: true,
          alphaMap: particleTexture,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
        });
        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      // Create a surface plane (filled) with optional wireframe and contour base
      function createSurface() {
        disposeObjects();
        const seg = Math.max(4, Math.floor(params.segments));
        const geometry = new THREE.PlaneBufferGeometry(
          params.width,
          params.height,
          seg,
          seg
        );
        geometry.rotateX(-Math.PI / 2); // make X-Z plane

        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;
        const colors = new Float32Array(count * 3);

        // Initialize positions and colors
        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const x = positions[i3];
          const z = positions[i3 + 2];
          positions[i3 + 1] = 0;
          
          // Initial color based on position
          const normX = (x / params.width) + 0.5;
          const normZ = (z / params.height) + 0.5;
          const t = (normX + normZ) * 0.5;
          const c = heightToColor(t, params.colorMap);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }
        
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();

        // Material with vertex colors
        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          shininess: 60,
          side: THREE.DoubleSide,
          flatShading: false,
          transparent: true,
          opacity: 0.9,
        });

        surface = new THREE.Mesh(geometry, material);
        scene.add(surface);

        // Wireframe overlay
        if (params.wireframe) {
          const geo = new THREE.WireframeGeometry(geometry);
          wireframeMesh = new THREE.LineSegments(
            geo,
            new THREE.LineBasicMaterial({ 
              color: 0x000000, 
              linewidth: 1,
              transparent: true,
              opacity: 0.3
            })
          );
          scene.add(wireframeMesh);
        }

        // Contour base plane
        contourPlane = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(
            params.width * 1.1,
            params.height * 1.1,
            1,
            1
          ),
          new THREE.MeshBasicMaterial({
            color: 0x222222,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
          })
        );
        contourPlane.rotateX(-Math.PI / 2);
        contourPlane.position.y = -2.5;
        scene.add(contourPlane);
      }

      // Dispose any previous objects
      function disposeObjects() {
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        if (surface) {
          scene.remove(surface);
          surface.geometry.dispose();
          surface.material.dispose();
          surface = null;
        }
        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMesh.geometry.dispose();
          wireframeMesh.material.dispose();
          wireframeMesh = null;
        }
        if (contourPlane) {
          scene.remove(contourPlane);
          contourPlane.geometry.dispose();
          contourPlane.material.dispose();
          contourPlane = null;
        }
      }

      // Rebuild depending on params.mode
      function rebuild() {
        if (params.mode === "particles") {
          createParticles();
        } else {
          createSurface();
        }
      }

      // Initial build
      rebuild();

      // GUI - Improved organization
      const gui = new dat.GUI({
        autoPlace: true,
        width: 300,
        closed: true // Start with panel closed
      });

      // Display Mode
      const modeFolder = gui.addFolder('Display Mode');
      modeFolder.add(params, 'mode', ['particles', 'surface']).name('Mode').onChange(rebuild);
      modeFolder.open();

      // Presets
      const presetFolder = gui.addFolder('Presets');
      presetFolder.add(params, 'applyPresetImageLook').name('Image Look');
      presetFolder.add(params, 'applyPresetParticles').name('Particle Field');
      presetFolder.add(params, 'applyPresetCalm').name('Calm Waves');
      presetFolder.close();

      // Particles Settings
      const particleFolder = gui.addFolder('Particle Settings');
      particleFolder.add(params, 'particleCount', 1000, 50000, 1000)
        .name('Count')
        .onFinishChange(() => {
          if (params.mode === 'particles') rebuild();
        });
      particleFolder.add(params, 'particleSize', 0.02, 0.5, 0.01)
        .name('Size')
        .onChange(() => {
          if (points) points.material.size = params.particleSize;
        });
      particleFolder.close();

      // Surface Settings
      const surfaceFolder = gui.addFolder('Surface Settings');
      surfaceFolder.add(params, 'segments', 4, 200, 1)
        .name('Resolution')
        .onFinishChange(() => {
          if (params.mode === 'surface') rebuild();
        });
      surfaceFolder.add(params, 'width', 1, 30, 0.5)
        .name('Width')
        .onFinishChange(rebuild);
      surfaceFolder.add(params, 'height', 1, 30, 0.5)
        .name('Height')
        .onFinishChange(rebuild);
      surfaceFolder.add(params, 'wireframe')
        .name('Wireframe')
        .onChange(() => {
          if (params.mode === 'surface') rebuild();
        });
      surfaceFolder.add(params, 'colorMap', ['height', 'coolwarm', 'rainbow'])
        .name('Color Scheme')
        .onChange(() => {
          if (params.mode === 'surface') rebuild();
        });
      surfaceFolder.close();

      // Wave Settings
      const waveFolder = gui.addFolder('Wave Settings');
      waveFolder.add(params, 'amplitude', 0.1, 3, 0.1).name('Amplitude');
      waveFolder.add(params, 'frequency', 0.1, 5, 0.1).name('Frequency');
      waveFolder.add(params, 'speed', 0.1, 3, 0.1).name('Speed');
      waveFolder.open();

      // Camera Controls
      const cameraFolder = gui.addFolder('Camera');
      cameraFolder.add(params, 'autoRotate').name('Auto Rotate');
      cameraFolder.add(params, 'rotationSpeed', 0.1, 2, 0.1).name('Rotation Speed');
      cameraFolder.close();

      // Animation loop
      function animate() {
        const t = clock.getElapsedTime() * params.speed;

        // Update points
        if (points) {
          const pos = points.geometry.attributes.position.array;
          const colors = points.geometry.attributes.color.array;
          const count = pos.length / 3;
          
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            
            // Combined wave functions for more organic motion
            const wave1 = Math.sin((x * 0.3 + t) * params.frequency);
            const wave2 = Math.cos((z * 0.3 + t * 0.7) * params.frequency * 0.8);
            const wave3 = Math.sin((x + z) * 0.2 + t * 0.5) * 0.5;
            const y = (wave1 * wave2 + wave3) * params.amplitude;
            
            pos[i3 + 1] = y;
            
            // Update colors based on height
            const heightNormalized = (y / params.amplitude + 1) * 0.5;
            const color = heightToColor(heightNormalized, 'height');
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
          }
          
          points.geometry.attributes.position.needsUpdate = true;
          points.geometry.attributes.color.needsUpdate = true;
        }

        // Update surface
        if (surface) {
          const pos = surface.geometry.attributes.position.array;
          const colors = surface.geometry.attributes.color.array;
          const vertCount = pos.length / 3;
          let minY = Infinity, maxY = -Infinity;
          
          // First pass: compute heights
          for (let i = 0; i < vertCount; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            
            const wave1 = Math.sin((x * 0.3 + t) * params.frequency);
            const wave2 = Math.cos((z * 0.3 + t * 0.7) * params.frequency * 0.8);
            const wave3 = Math.sin((x + z) * 0.2 + t * 0.5) * 0.5;
            const y = (wave1 * wave2 + wave3) * params.amplitude;
            
            pos[i3 + 1] = y;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
          
          // Second pass: update colors
          const range = Math.max(0.0001, maxY - minY);
          for (let i = 0; i < vertCount; i++) {
            const i3 = i * 3;
            const y = pos[i3 + 1];
            const tcol = (y - minY) / range;
            const c = heightToColor(tcol, params.colorMap);
            colors[i3] = c.r;
            colors[i3 + 1] = c.g;
            colors[i3 + 2] = c.b;
          }
          
          surface.geometry.attributes.position.needsUpdate = true;
          surface.geometry.attributes.color.needsUpdate = true;
          surface.geometry.computeVertexNormals();

          // Update wireframe
          if (wireframeMesh && params.wireframe) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(surface.geometry);
          }
        }

        // Auto rotation
        if (params.autoRotate) {
          camera.position.x = Math.cos(t * 0.1 * params.rotationSpeed) * 7;
          camera.position.z = Math.sin(t * 0.1 * params.rotationSpeed) * 7;
          camera.lookAt(0, 0, 0);
        } else {
          controls.update();
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Handle key press to toggle GUI (optional)
      window.addEventListener('keydown', (e) => {
        if (e.key === 'h' || e.key === 'H') {
          gui.closed = !gui.closed;
        }
      });

      // Start animation
      animate();
    </script>
  </body>
</html>