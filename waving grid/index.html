<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Waving Grid – openFrameworks clone</title>
    <style>
        /* ---------------- CSS ---------------- */
        body{
            margin:0;
            overflow:hidden;
            background: #eff3f4;          /* the same background colour (239) */
        }

        #gridCanvas{
            display:block;
            width:100vw;
            height:100vh;
        }
    </style>
</head>
<body>

<canvas id="gridCanvas"></canvas>

<script>
// ------------------- JavaScript -------------------

const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');

// Resize canvas when the window changes size
function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Settings – the same values that are used in the OF code
const SPAN      = 50;          // distance between two lines
const AMPLITUDE = 15;          // max height of the wave
const TIME_SPEED= 0.0005;      // animation speed

// --------------------------------------------------------------
// A simple 2‑D noise function.
// It does not use real Perlin noise but gives a smooth animated pattern.
// --------------------------------------------------------------
function noise(x, y, time) {
    let value = 0;

    // Combine several sine waves to obtain a smooth looking noise
    value += Math.sin(x * 0.003 + time * TIME_SPEED);
    value += 0.5 * Math.sin(y * 0.003 + time * TIME_SPEED);
    value += 0.3 * Math.sin((x + y) * 0.005 + time * TIME_SPEED);

    // The sum is between approximately -2 and 2 → normalise to [0, 1]
    return (value + 2) / 4;
}

// Counter that works like ofGetFrameNum()
let frame = 0;

function drawGrid(){
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Save the current transformation matrix
    ctx.save();

    /* In the OF example the camera is rotated with ofRotateX(270).
       We emulate that by moving the origin to the centre of the canvas
       and rotating the whole scene –90 degrees. */
    ctx.translate(canvas.width / 2, canvas.height / 2);   // centre
    ctx.rotate(-Math.PI / 2);                              // -90°

    // Draw the same light grey background as in OF
    ctx.fillStyle = '#eff3f4';
    ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);

    // Loop through the grid.
    // The grid is drawn from the centre outward so it is always centred.
    for(let x = -canvas.width; x <= canvas.width; x += SPAN){
        for(let y = -canvas.height; y <= canvas.height; y += SPAN){

            // Compute noise for the current cell.
            const n = noise(x, y, frame);

            // In OF the height is calculated with
            //      pow(ofMap(noise_value,0,1,0,28), 2)
            // Here we simplify it to pow(n,2) * AMPLITUDE
            const height = Math.pow(n, 2) * AMPLITUDE;

            // Vertices of the current cell
            const p1 = {x: x    , y: y    };
            const p2 = {x: x+SPAN, y: y    };
            const p3 = {x: x+SPAN, y: y+SPAN};
            const p4 = {x: x    , y: y+SPAN};

            // ------------------------------------------------------
            //  Draw the coloured face
            // ------------------------------------------------------
            // Hue changes every 500 frames – exactly as in the OF code
            const hue = (frame % 500) * 360 / 500;  
            ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.9)`;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.fill();

            // ------------------------------------------------------
            //  Draw the wireframe (black lines) on top
            // ------------------------------------------------------
            ctx.strokeStyle = '#000';
            ctx.lineWidth   = 1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.stroke();
        }
    }

    ctx.restore();          // restore the original transformation
    frame++;                // next frame
}

// Animation loop
function animate(){
    drawGrid();
    requestAnimationFrame(animate);
}

animate();   // start animation
</script>
</body>
</html>