<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Three Fiber - Depixelation</title>
    <style>
        body, html, #root {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
    </style>
    
    <!-- Load Babel to process JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for dependencies -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11",
        "postprocessing": "https://esm.sh/postprocessing@6.34.0",
        "leva": "https://esm.sh/leva@0.9.35",
        "maath": "https://esm.sh/maath@0.10.7"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <!-- Note: type="text/babel" and data-type="module" allows Babel to handle JSX + Imports -->
    <script type="text/babel" data-type="module">
        import React, { useRef, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { OrbitControls, OrthographicCamera, Image } from '@react-three/drei';
        import { EffectComposer, wrapEffect } from '@react-three/postprocessing';
        import { Effect } from 'postprocessing';
        import { Leva, useControls } from 'leva';
        import { easing } from 'maath';

        const fragmentShader = `
        uniform float progress;
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        const float LEVELS = 5.0;
        void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
          float basePixelSize = pow(2.0, LEVELS);
          float currentLevel = floor(progress * LEVELS);  
          float currentPixelSize = max(basePixelSize / pow(2.0, currentLevel), 1.0);
          float currentPixelsPerRow = ceil(resolution.x / currentPixelSize);
          float currentPixelsPerCol = ceil(resolution.y / currentPixelSize);
          float currentTotalPixels = currentPixelsPerRow * currentPixelsPerCol;
          float levelProgress = fract(progress * LEVELS) * currentTotalPixels;
          float currentRowInLevel = floor(levelProgress / currentPixelsPerRow);
          float currentPixelInRow = mod(levelProgress, currentPixelsPerRow);
          vec2 gridPos = floor(uv * resolution / currentPixelSize);
          float row = floor(currentPixelsPerCol - gridPos.y - 1.0);
          float posInRow = floor(gridPos.x);
          vec4 additionalColor = vec4(0.0, 0.0, 0.0, 1.0);
          vec2 finalUv;
          if (currentPixelSize <= 1.0) {
            finalUv = uv;
            additionalColor = vec4(0.0);
          } else if (row < currentRowInLevel || (row == currentRowInLevel && posInRow <= currentPixelInRow)) {
            vec2 finalNormalizedPixelSize = currentPixelSize / resolution;
            finalUv = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
            if (row == currentRowInLevel) {
              float rand = random(vec2(posInRow, row));
              float twinkle = sin(time * 10.0 + rand * 10.0) + 1.0;
              additionalColor = vec4(0.005) * (twinkle * 20.0);
            }
          } else {
            float finalPixelSize = currentPixelSize * 2.0;
            vec2 finalNormalizedPixelSize = finalPixelSize / resolution;
            finalUv = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
          }
          outputColor = texture2D(inputBuffer, finalUv) + additionalColor;
        }
        `;

        class CustomDepixelationEffectImpl extends Effect {
          constructor({ progress = 0.0 }) {
            super('CustomDepixelationEffect', fragmentShader, {
              uniforms: new Map([['progress', new THREE.Uniform(progress)]]),
            });
          }
          update(_renderer, _inputBuffer, _deltaTime) {
            this.uniforms.get('progress').value = this.progress;
          }
        }

        const CustomDepixelationEffect = wrapEffect(CustomDepixelationEffectImpl);

        const DepixelationEffect = () => {
          const effectRef = useRef();
          const smoothProgressRef = useRef(0);
          const { progress } = useControls({
            progress: { value: 0.0, min: 0.0, max: 1.0, step: 0.001 },
          });

          useFrame((state, delta) => {
            easing.damp(smoothProgressRef, 'current', progress, 0.25, delta);
            if (effectRef.current) effectRef.current.progress = smoothProgressRef.current;
          });

          return (
            <EffectComposer>
              <CustomDepixelationEffect ref={effectRef} progress={0} />
            </EffectComposer>
          );
        };

        const FullScreenImage = () => {
          const meshRef = useRef();
          const { viewport } = useThree();
          useFrame((state) => {
            if(meshRef.current) meshRef.current.rotation.setFromQuaternion(state.camera.quaternion);
          });
          return (
            <Image
              ref={meshRef}
              scale={[viewport.width, viewport.height, 1.0]}
              url='https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg'
            />
          );
        };

        const Scene = () => {
          return (
            <>
              <Canvas shadows dpr={[1, 1.5]}>
                <Suspense fallback={null}>
                  <color attach='background' args={['#74B7FF']} />
                  <OrthographicCamera makeDefault position={[0, 0, 10]} zoom={100} />
                  <FullScreenImage />
                  <DepixelationEffect />
                  <OrbitControls />
                </Suspense>
              </Canvas>
              <Leva collapsed />
            </>
          );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<Scene />);
    </script>
</body>
</html>