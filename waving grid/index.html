<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Interactive Wireframe Platform</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="info">
        Double-click to toggle wireframe/filled view
    </div>
    
    <script>
        // Simplex-like noise using ImprovedNoise class
        class ImprovedNoise {
            constructor() {
                this.p = new Array(512);
                const permutation = [
                    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7,
                    225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6,
                    148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35,
                    11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
                    168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231,
                    83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245,
                    40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76,
                    132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
                    164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,
                    202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
                    58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
                    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
                    19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
                    97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
                    81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199,
                    106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
                    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78,
                    66, 215, 61, 156, 180,
                ];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = permutation[i];
                }
            }
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            lerp(t, a, b) {
                return a + t * (b - a);
            }
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                const u = this.fade(x),
                    v = this.fade(y),
                    w = this.fade(z);
                const A = this.p[X] + Y,
                    AA = this.p[A] + Z,
                    AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y,
                    BA = this.p[B] + Z,
                    BB = this.p[B + 1] + Z;
                return (
                    this.lerp(
                        w,
                        this.lerp(
                            v,
                            this.lerp(
                                u,
                                this.grad(this.p[AA], x, y, z),
                                this.grad(this.p[BA], x - 1, y, z)
                            ),
                            this.lerp(
                                u,
                                this.grad(this.p[AB], x, y - 1, z),
                                this.grad(this.p[BB], x - 1, y - 1, z)
                            )
                        ),
                        this.lerp(
                            v,
                            this.lerp(
                                u,
                                this.grad(this.p[AA + 1], x, y, z - 1),
                                this.grad(this.p[BA + 1], x - 1, y, z - 1)
                            ),
                            this.lerp(
                                u,
                                this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                this.grad(this.p[BB + 1], x - 1, y - 1, z - 1)
                            )
                        )
                    ) *
                        0.5 +
                    0.5
                );
            }
        }

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 1000, 6000);

        const camera = new THREE.PerspectiveCamera(
            50,
            window.innerWidth / window.innerHeight,
            1,
            10000
        );
        camera.position.set(0, 300, 1200);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(1, 1, 1);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x222222));

        const noise = new ImprovedNoise();
        const width = 6000,
            height = 6000,
            seg = 150;
        const geometry = new THREE.PlaneGeometry(width, height, seg, seg);

        // Material with dynamic color & visible wireframe
        const material = new THREE.MeshPhongMaterial({
            color: 0x0077ff,
            emissive: 0x001020,
            side: THREE.DoubleSide,
            wireframe: true,
            wireframeLinewidth: 1,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        scene.add(mesh);

        // Double-click event listener
        let isWireframe = true;
        renderer.domElement.addEventListener('dblclick', function() {
            isWireframe = !isWireframe;
            material.wireframe = isWireframe;
            
            // Adjust material properties for filled view
            if (!isWireframe) {
                material.transparent = true;
                material.opacity = 0.9;
                material.emissiveIntensity = 0.3;
            } else {
                material.transparent = false;
                material.emissiveIntensity = 1.0;
            }
        });

        let t = 0;
        function animate() {
            requestAnimationFrame(animate);
            t += 0.02;

            const pos = geometry.attributes.position;
            const arr = pos.array;
            for (let i = 0; i < arr.length; i += 3) {
                const x = arr[i];
                const y = arr[i + 1];
                const val = noise.noise(x * 0.002, (y + t * 1000) * 0.002, t * 0.5);
                arr[i + 2] = val * 800 - 400; // ðŸ”¥ Higher amplitude waves
            }
            pos.needsUpdate = true;
            mesh.geometry.computeVertexNormals();

            // Smooth color change with time (cycling through hues)
            const hue = (Math.sin(t * 0.3) * 0.5 + 0.5) * 0.7;
            material.color.setHSL(hue, 1.0, 0.5);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>