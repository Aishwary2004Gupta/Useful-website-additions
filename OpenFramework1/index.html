<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ring Mesh — Three.js Version</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #efefef;
        font-family: Arial, sans-serif;
        transition: background 0.3s ease;
      }
      canvas {
        display: block;
      }
      #toggleBtn {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 16px;
        background: transparent;
        color: #000;
        border: none;
        border-radius: 0;
        cursor: pointer;
        z-index: 100;
        transition: all 0.3s ease;
        padding: 0;
        font-weight: bold;
      }
      #toggleBtn:hover {
        opacity: 0.7;
        transform: scale(1.05);
      }
      body.dark-mode #toggleBtn {
        color: #fff;
      }
      body.dark-mode #toggleBtn:hover {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <button id="toggleBtn">[ Light ]</button>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js";

      ///////////////////////////////////////////////////////////////////////////
      // SCENE SETUP
      ///////////////////////////////////////////////////////////////////////////
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      const camera = new THREE.PerspectiveCamera(
        80,
        innerWidth / innerHeight,
        0.1,
        3000
      );
      camera.position.set(0, -300, 600);

      // Lower devicePixelRatio cap to reduce GPU load
      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
      // Disable expensive shadow path for smoother frame times
      renderer.shadowMap.enabled = false;

      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Dark mode state - set to true by default
      let isDarkMode = true;
      
      // Apply dark mode on startup
      document.body.classList.add('dark-mode');

      ///////////////////////////////////////////////////////////////////////////
      // MATERIALS (reuse, swap on mode change)
      ///////////////////////////////////////////////////////////////////////////
      const faceMat_light = new THREE.MeshStandardMaterial({ color: 0xefefef, roughness: 0.45, metalness: 0.05, side: THREE.DoubleSide });
      const faceMat_dark = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6, metalness: 0.08, side: THREE.DoubleSide });
      const frameMat_light = new THREE.LineBasicMaterial({ color: 0x272727 });
      const frameMat_dark = new THREE.LineBasicMaterial({ color: 0xefefef });

      ///////////////////////////////////////////////////////////////////////////
      // Keep a root for subtle scene rotation
      ///////////////////////////////////////////////////////////////////////////
      const root = new THREE.Group();
      scene.add(root);

      ///////////////////////////////////////////////////////////////////////////
      // Create a reusable BufferGeometry for a 90° ring segment (built once)
      ///////////////////////////////////////////////////////////////////////////
      function buildRingGeometry(radius, width, height, segAngle = 90, stepDeg = 3) {
        const positions = [];
        const indices = [];
        const radFactor = Math.PI / 180;
        let idx = 0;
        // build using stepDeg resolution (lower = fewer verts)
        for (let deg = 0; deg < segAngle; deg += stepDeg) {
          const deg2 = Math.min(deg + stepDeg, segAngle);
          const rad1 = deg * radFactor;
          const rad2 = deg2 * radFactor;

          // outer quad (two vertices per edge at -h/2 and +h/2)
          const o1 = [(radius + width / 2) * Math.cos(rad1), (radius + width / 2) * Math.sin(rad1)];
          const o2 = [(radius + width / 2) * Math.cos(rad2), (radius + width / 2) * Math.sin(rad2)];
          const i1 = [(radius - width / 2) * Math.cos(rad1), (radius - width / 2) * Math.sin(rad1)];
          const i2 = [(radius - width / 2) * Math.cos(rad2), (radius - width / 2) * Math.sin(rad2)];

          // push 8 verts (outer -z, outer +z, inner -z, inner +z) for this quad segment
          positions.push(...o1, -height / 2);
          positions.push(...o2, -height / 2);
          positions.push(...o2, height / 2);
          positions.push(...o1, height / 2);
          positions.push(...i1, -height / 2);
          positions.push(...i2, -height / 2);
          positions.push(...i2, height / 2);
          positions.push(...i1, height / 2);

          // two face quads + side faces (same indexing pattern as original)
          indices.push(
            idx + 0, idx + 1, idx + 2, idx + 0, idx + 2, idx + 3,
            idx + 4, idx + 5, idx + 6, idx + 4, idx + 6, idx + 7,
            idx + 0, idx + 4, idx + 5, idx + 0, idx + 5, idx + 1,
            idx + 3, idx + 7, idx + 6, idx + 3, idx + 6, idx + 2
          );

          idx += 8;
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geom.setIndex(indices);
        geom.computeVertexNormals(); // compute once
        return geom;
      }

      ///////////////////////////////////////////////////////////////////////////
      // INSTANCED SETUP (create two instanced meshes and reuse them)
      ///////////////////////////////////////////////////////////////////////////
      // z distribution settings (fewer instances => smoother)
      const zMin = -600, zMax = 600, zStep = 30; // was 20, now 30 -> fewer instances
      const zPositions = [];
      for (let z = zMin; z <= zMax; z += zStep) zPositions.push(z);
      const instanceCount = zPositions.length;

      // prebuilt geometries (90° segment)
      const innerGeom = buildRingGeometry(150, 5, 15, 90, 3); // coarser step
      const outerGeom = buildRingGeometry(300, 5, 15, 90, 3);

      // instanced meshes
      const innerInst = new THREE.InstancedMesh(innerGeom, isDarkMode ? faceMat_dark : faceMat_light, instanceCount);
      const outerInst = new THREE.InstancedMesh(outerGeom, isDarkMode ? faceMat_dark : faceMat_light, instanceCount);
      innerInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // will update each frame
      outerInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      // add lines (lightweight) as non-instanced single-line outlines optional — omitted for perf
      root.add(innerInst);
      root.add(outerInst);

      // temporary objects for matrix updates (reuse to avoid allocations)
      const tmpPos = new THREE.Vector3();
      const tmpQuat = new THREE.Quaternion();
      const tmpScale = new THREE.Vector3(1, 1, 1);
      const tmpMat = new THREE.Matrix4();

      // initial matrix setup
      function updateInstanceMatrices(frameNum) {
        for (let i = 0; i < instanceCount; i++) {
          const z = zPositions[i];
          // compute degStart like original but without per-degree loop
          const degStartInner = frameNum + z + 600 - frameNum * 2; // matches original inner behavior
          const degStartOuter = frameNum + z + 600 + 180;

          // inner instance
          tmpPos.set(0, -0.0, z); // y translation handled globally via group position in original, keep z here
          tmpQuat.setFromAxisAngle(new THREE.Vector3(0,0,1), THREE.MathUtils.degToRad(degStartInner));
          tmpMat.compose(tmpPos, tmpQuat, tmpScale);
          innerInst.setMatrixAt(i, tmpMat);

          // outer instance
          tmpPos.set(0, -0.0, z);
          tmpQuat.setFromAxisAngle(new THREE.Vector3(0,0,1), THREE.MathUtils.degToRad(degStartOuter));
          tmpMat.compose(tmpPos, tmpQuat, tmpScale);
          outerInst.setMatrixAt(i, tmpMat);
        }
        innerInst.instanceMatrix.needsUpdate = true;
        outerInst.instanceMatrix.needsUpdate = true;
      }

      // initial populate
      updateInstanceMatrices(performance.now() * 0.06);

      ///////////////////////////////////////////////////////////////////////////
      // TOGGLE DARK/LIGHT MODE (swap materials on instanced meshes)
      ///////////////////////////////////////////////////////////////////////////
      function toggleDarkMode() {
        isDarkMode = !isDarkMode;
        const btn = document.getElementById('toggleBtn');
        btn.textContent = isDarkMode ? '[ Light ]' : '[ Dark ]';
        
        if (isDarkMode) {
          document.body.classList.add('dark-mode');
          scene.background.setHex(0x1a1a1a);
          innerInst.material = faceMat_dark;
          outerInst.material = faceMat_dark;
        } else {
          document.body.classList.remove('dark-mode');
          scene.background.setHex(0xefefef);
          innerInst.material = faceMat_light;
          outerInst.material = faceMat_light;
        }
      }

      document.getElementById('toggleBtn').addEventListener('click', toggleDarkMode);

      ///////////////////////////////////////////////////////////////////////////
      // ANIMATION LOOP (only update instance matrices each frame)
      ///////////////////////////////////////////////////////////////////////////
      function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001; // seconds
        const frameNum = performance.now() * 0.06;

        // update per-instance rotation/phase (fast)
        updateInstanceMatrices(frameNum);

        // gentle vertical motion like original but applied to instanced groups via root children positions
        const innerAmplitude = 8;
        const outerAmplitude = 12;
        const innerSpeed = 2.0;
        const outerSpeed = 2.5;
        innerInst.position.y = -Math.sin(time * innerSpeed) * innerAmplitude;
        outerInst.position.y = -Math.sin(time * outerSpeed) * outerAmplitude;

        // reveal 3D
        root.rotation.x = Math.PI / 2 - 0.6;
        root.rotation.y = time * 0.08;

        renderer.render(scene, camera);
      }

      animate();

      ///////////////////////////////////////////////////////////////////////////
      // RESIZE
      ///////////////////////////////////////////////////////////////////////////
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
