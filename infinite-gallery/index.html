<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Infinite 3D Image Gallery</title>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family: Inter, system-ui, sans-serif; }
    #canvas-wrap { position:relative; width:100%; height:100vh; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }
    .center-title {
      position:fixed; inset:0; display:flex; pointer-events:none;
      align-items:center; justify-content:center; text-align:center;
      mix-blend-mode:exclusion; color:#fff;
    }
    .center-title h1 { font-family: serif; font-style:italic; font-size:2.2rem; margin:0; }
    @media(min-width:768px){ .center-title h1{ font-size:4rem } }
    .footer {
      position:fixed; left:0; right:0; bottom:2.5rem; text-align:center;
      font-family:monospace; font-size:11px; font-weight:600;
    }
    .footer .muted { opacity:0.6; display:block }
    /* small pointer hint for hover */
    .hint { position:fixed; right:1rem; bottom:1rem; font-size:12px; opacity:0.7 }
  </style>
</head>
<body>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
  </div>

  <div class="center-title">
    <h1><span style="font-style:italic">I create;</span> therefore I am</h1>
  </div>

  <div class="footer">
    <div>Use mouse wheel, arrow keys, or touch to navigate</div>
    <div class="muted">Auto-play resumes after 3 seconds of inactivity</div>
  </div>

  <div class="hint">Tip: hover an image to see wave effect</div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
  (function(){
    // sample images (from your list)
    const sampleImages = [
      "https://images.pexels.com/photos/1366919/pexels-photo-1366919.jpeg?auto=compress&cs=tinysrgb&w=1200",
      "https://images.pexels.com/photos/1761279/pexels-photo-1761279.jpeg?auto=compress&cs=tinysrgb&w=1200",
      "https://images.pexels.com/photos/1624496/pexels-photo-1624496.jpeg?auto=compress&cs=tinysrgb&w=1200",
      "https://images.pexels.com/photos/1770809/pexels-photo-1770809.jpeg?auto=compress&cs=tinysrgb&w=1200",
      "https://images.unsplash.com/photo-1759434188986-58432949b5a4?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=698",
      "https://images.unsplash.com/photo-1521722566572-164b5b53ec66?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=687",
      "https://images.unsplash.com/photo-1731432250020-6810b97db4bb?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=687",
      "https://images.unsplash.com/photo-1761165308084-392672e8e7cf?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=687",
      "https://plus.unsplash.com/premium_photo-1761211108987-c37052604d95?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=715",
      "https://images.unsplash.com/photo-1761432833529-c8920fa699f0?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=735",
      "https://images.unsplash.com/photo-1761424384120-81134aef0d8d?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=687",
      "https://images.unsplash.com/photo-1761405378282-e819a65cb493?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=764",
    ];

    // Config
    const VISIBLE_COUNT = 12;
    const DEPTH_RANGE = 50;
    const Z_SPACING = DEPTH_RANGE / VISIBLE_COUNT;
    const SPEED = 1.2;
    const AUTO_RESUME_MS = 3000;
    const MAX_BLUR = 6.0;

    // Three.js setup
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,0.001); // camera at origin, we'll place planes around z

    const clock = new THREE.Clock();

    // Resize
    function onResize(){
      const w = innerWidth; const h = innerHeight;
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize, {passive:true});
    onResize();

    // Shader (vertex + fragment) to approximate cloth + blur + opacity
    const vertexShader = `
      uniform float scrollForce;
      uniform float time;
      uniform float isHovered;
      varying vec2 vUv;
      void main(){
        vUv = uv;
        vec3 p = position;
        float curveIntensity = scrollForce * 0.18;
        float distanceFromCenter = length(p.xy);
        float curve = distanceFromCenter * distanceFromCenter * curveIntensity;
        float ripple1 = sin(p.x * 6.0 + scrollForce * 2.0) * 0.02;
        float ripple2 = sin(p.y * 5.0 + scrollForce * 1.3) * 0.015;
        float clothEffect = (ripple1 + ripple2) * abs(curveIntensity) * 2.0;
        float flagWave = 0.0;
        if (isHovered > 0.5) {
          float wavePhase = p.x * 4.0 + time * 6.0;
          float waveAmplitude = sin(wavePhase) * 0.08;
          float dampening = smoothstep(-0.5, 0.5, p.x);
          flagWave = waveAmplitude * dampening + sin(p.x*8.0+time*12.0)*0.02*dampening;
        }
        p.z -= (curve + clothEffect + flagWave);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
      }
    `;

    const fragmentShader = `
      precision highp float;
      varying vec2 vUv;
      uniform sampler2D map;
      uniform float opacity;
      uniform float blurAmount;
      uniform float scrollForce;
      void main(){
        vec4 color = texture2D(map, vUv);

        // cheap blur: sample a few neighboring texels depending on blurAmount
        if (blurAmount > 0.01) {
          vec2 texel = vec2(1.0)/vec2(textureSize(map,0));
          vec4 acc = vec4(0.0);
          float tot = 0.0;
          for (int x=-1; x<=1; x++){
            for (int y=-1; y<=1; y++){
              float w = 1.0 / (1.0 + length(vec2(x,y)));
              acc += texture2D(map, vUv + vec2(float(x),float(y))*texel*blurAmount) * w;
              tot += w;
            }
          }
          color = acc / tot;
        }

        float highlight = abs(scrollForce)*0.03;
        color.rgb += vec3(highlight*0.08);

        gl_FragColor = vec4(color.rgb, color.a * opacity);
      }
    `;

    // Load textures
    const loader = new THREE.TextureLoader();
    const textures = [];
    let loaded = 0;
    sampleImages.forEach((url, i) => {
      loader.load(url, (tex) => {
        tex.minFilter = THREE.LinearFilter;
        textures[i] = tex;
        loaded++;
        if (loaded === sampleImages.length) initScene();
      }, undefined, (err)=>{ console.warn('tex fail', err); loaded++; if (loaded===sampleImages.length) initScene(); });
    });

    // fallback: if textures never load quickly, still init after 1s
    setTimeout(()=>{ if(loaded===0){ sampleImages.forEach(()=>loaded++); initScene(); } }, 1200);

    // Keep track of planes
    const planes = [];
    const materials = [];
    const planeData = []; // {index, z, imageIndex, x, y}
    let scrollVelocity = 0;
    let autoPlay = true;
    let lastInteraction = Date.now();

    // spatial offsets (natural distribution)
    function computeSpatial(i){
      const maxX = 6, maxY = 3.8;
      const horizontalAngle = (i * 2.618) % (Math.PI*2);
      const verticalAngle = (i * 1.618 + Math.PI/3) % (Math.PI*2);
      const horizontalRadius = (i % 3) * 1.2;
      const verticalRadius = ((i + 1) % 4) * 0.8;
      const x = (Math.sin(horizontalAngle) * horizontalRadius * maxX)/3;
      const y = (Math.cos(verticalAngle) * verticalRadius * maxY)/4;
      return {x,y};
    }

    function initScene(){
      // create visibleCount planes
      const totalImages = textures.length || sampleImages.length;
      for (let i=0;i<VISIBLE_COUNT;i++){
        const mat = new THREE.ShaderMaterial({
          uniforms:{
            map: { value: textures[i % totalImages] || new THREE.Texture() },
            opacity: { value: 1.0 },
            blurAmount: { value: 0.0 },
            scrollForce: { value: 0.0 },
            time: { value: 0.0 },
            isHovered: { value: 0.0 }
          },
          vertexShader,
          fragmentShader,
          transparent: true,
          depthTest: true,
          depthWrite: false
        });
        const geom = new THREE.PlaneGeometry(2, 1.2, 32, 32);
        const mesh = new THREE.Mesh(geom, mat);
        // aspect correction set scale after texture loads or fallback
        const tex = textures[i % totalImages];
        if (tex && tex.image && tex.image.width && tex.image.height){
          const aspect = tex.image.width / tex.image.height;
          const scaleX = aspect > 1 ? 2 * aspect : 2;
          const scaleY = aspect > 1 ? 2 : 2 / aspect;
          mesh.scale.set(scaleX, scaleY, 1);
        } else {
          mesh.scale.set(2, 2, 1);
        }

        scene.add(mesh);
        materials.push(mat);
        planes.push(mesh);
        const sp = computeSpatial(i);
        const z = (Z_SPACING * i) % DEPTH_RANGE;
        planeData.push({ index: i, z, imageIndex: i % totalImages, x: sp.x, y: sp.y });
      }

      // initial position update
      updatePlanePositions(0);

      // Interactions
      const wrap = document.getElementById('canvas-wrap');

      // wheel
      function onWheel(e){
        e.preventDefault();
        scrollVelocity += (e.deltaY * 0.01) * SPEED;
        autoPlay = false;
        lastInteraction = Date.now();
      }
      wrap.addEventListener('wheel', onWheel, { passive:false });

      // keys
      window.addEventListener('keydown', (ev)=>{
        if (ev.key === 'ArrowUp' || ev.key==='ArrowLeft'){
          scrollVelocity -= 2 * SPEED;
          autoPlay = false;
          lastInteraction = Date.now();
        } else if (ev.key === 'ArrowDown' || ev.key==='ArrowRight'){
          scrollVelocity += 2 * SPEED;
          autoPlay = false;
          lastInteraction = Date.now();
        }
      });

      // touch - translate vertical drag to scroll velocity
      let touchStartY = null;
      window.addEventListener('touchstart', (t)=>{ if(t.touches && t.touches[0]) touchStartY = t.touches[0].clientY; });
      window.addEventListener('touchmove', (t)=>{ if(t.touches && t.touches[0] && touchStartY!==null){ const dy = touchStartY - t.touches[0].clientY; scrollVelocity += dy*0.01*SPEED; touchStartY = t.touches[0].clientY; autoPlay=false; lastInteraction=Date.now(); } }, {passive:true});
      window.addEventListener('touchend', ()=> touchStartY=null);

      // pointer hover detection for wave effect (raycast)
      const ray = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      let hoveredIndex = -1;

      function onPointerMove(e){
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
        pointer.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      }
      window.addEventListener('pointermove', onPointerMove);

      // animate
      requestAnimationFrame(animate);
    }

    function wrapIndex(idx, len){ return ((idx % len) + len) % len; }

    function updatePlanePositions(delta){
      const halfRange = DEPTH_RANGE/2;
      const totalImages = textures.length || sampleImages.length;

      // Update z positions, wrapping, and uniforms
      planeData.forEach((p, i)=>{
        let newZ = p.z + scrollVelocity * delta * 10;
        let wrapsForward = 0, wrapsBackward = 0;

        if (newZ >= DEPTH_RANGE){
          wrapsForward = Math.floor(newZ / DEPTH_RANGE);
          newZ -= DEPTH_RANGE * wrapsForward;
        } else if (newZ < 0){
          wrapsBackward = Math.ceil(-newZ / DEPTH_RANGE);
          newZ += DEPTH_RANGE * wrapsBackward;
        }

        if (wrapsForward > 0){
          const advance = VISIBLE_COUNT % totalImages || totalImages;
          p.imageIndex = (p.imageIndex + wrapsForward * advance) % totalImages;
          materials[i].uniforms.map.value = textures[p.imageIndex];
          // adjust aspect
          const tex = textures[p.imageIndex];
          if (tex && tex.image && tex.image.width && tex.image.height){
            const aspect = tex.image.width/tex.image.height;
            const scaleX = aspect > 1 ? 2*aspect : 2;
            const scaleY = aspect > 1 ? 2 : 2/aspect;
            planes[i].scale.set(scaleX, scaleY, 1);
          }
        }
        if (wrapsBackward > 0){
          const advance = VISIBLE_COUNT % totalImages || totalImages;
          const step = p.imageIndex - wrapsBackward * advance;
          p.imageIndex = wrapIndex(step, totalImages);
          materials[i].uniforms.map.value = textures[p.imageIndex];
          const tex = textures[p.imageIndex];
          if (tex && tex.image && tex.image.width && tex.image.height){
            const aspect = tex.image.width/tex.image.height;
            const scaleX = aspect > 1 ? 2*aspect : 2;
            const scaleY = aspect > 1 ? 2 : 2/aspect;
            planes[i].scale.set(scaleX, scaleY, 1);
          }
        }

        p.z = ((newZ % DEPTH_RANGE) + DEPTH_RANGE) % DEPTH_RANGE;

        // worldZ relative to center
        const worldZ = p.z - halfRange;
        const x = p.x; const y = p.y;
        planes[i].position.set(x, y, worldZ);

        // normalized position for fade/blur (0..1)
        const normalized = p.z / DEPTH_RANGE;
        // fade in/out
        let opacity = 1.0;
        const fadeIn = { start: 0.05, end: 0.15 };
        const fadeOut = { start: 0.85, end: 0.95 };
        if (normalized >= fadeIn.start && normalized <= fadeIn.end){
          const t = (normalized - fadeIn.start) / (fadeIn.end - fadeIn.start);
          opacity = t;
        } else if (normalized < fadeIn.start) opacity = 0;
        else if (normalized >= fadeOut.start && normalized <= fadeOut.end){
          const t = (normalized - fadeOut.start) / (fadeOut.end - fadeOut.start);
          opacity = 1 - t;
        } else if (normalized > fadeOut.end) opacity = 0;
        opacity = Math.max(0, Math.min(1, opacity));

        // blur -> map from near to far
        let blur = 0;
        const blurIn = { start: 0.0, end: 0.1 };
        const blurOut = { start: 0.9, end: 1.0 };
        if (normalized >= blurIn.start && normalized <= blurIn.end){
          const t = (normalized - blurIn.start) / (blurIn.end - blurIn.start);
          blur = MAX_BLUR * (1 - t);
        } else if (normalized < blurIn.start) blur = MAX_BLUR;
        else if (normalized >= blurOut.start && normalized <= blurOut.end){
          const t = (normalized - blurOut.start) / (blurOut.end - blurOut.start);
          blur = MAX_BLUR * t;
        } else if (normalized > blurOut.end) blur = MAX_BLUR;
        blur = Math.max(0, Math.min(MAX_BLUR, blur));

        // set uniforms
        const mat = materials[i];
        if (mat && mat.uniforms){
          mat.uniforms.opacity.value = opacity;
          mat.uniforms.blurAmount.value = blur;
          mat.uniforms.scrollForce.value = scrollVelocity;
        }
      });
    }

    // Simple raycast hover to toggle isHovered on materials
    const pointer = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    window.addEventListener('pointermove', (ev)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(planes, false);
      // clear all
      materials.forEach(m => m.uniforms.isHovered.value = 0.0);
      if (intersects.length>0){
        const idx = planes.indexOf(intersects[0].object);
        if (idx>=0) materials[idx].uniforms.isHovered.value = 1.0;
      }
    });

    // animation loop
    let lastT = 0;
    function animate(t){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, (t - lastT)/1000 || 0.016);
      lastT = t;

      // auto-play resume if idle
      if (Date.now() - lastInteraction > AUTO_RESUME_MS) autoPlay = true;

      if (autoPlay) scrollVelocity += 0.3 * dt; // gentle auto movement

      // damping
      scrollVelocity *= 0.95;

      // update uniforms time
      const time = clock.getElapsedTime();
      materials.forEach(m => { if(m.uniforms) m.uniforms.time.value = time; });

      updatePlanePositions(dt);

      renderer.render(scene, camera);
    }

    // If WebGL not supported: show fallback simple grid
    if (!renderer.capabilities || !renderer.capabilities.isWebGL2 && !renderer.extensions.get('OES_texture_float')){
      // fallback: replace canvas with simple list
      document.getElementById('canvas-wrap').innerHTML = '<div style="padding:24px;color:#111;background:#fff;border-radius:12px;margin:24px">WebGL not supported — showing list:<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:12px">' +
        sampleImages.map(u => `<img src="${u}" style="width:100%;height:140px;object-fit:cover;border-radius:8px"/>`).join('') +
        '</div></div>';
    }
  })();
  </script>
</body>
</html>
