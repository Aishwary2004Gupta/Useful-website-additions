<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ring Morph Animation</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #e8f1ff;
    }
    canvas { display: block; }
  </style>
</head>

<body>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ----------------------------------------------------------
   Renderer
---------------------------------------------------------- */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

/* ----------------------------------------------------------
   Scene + Camera
---------------------------------------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color("#e6f0ff");
scene.fog = new THREE.Fog("#e6f0ff", 12, 26);

const camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 9);

/* ----------------------------------------------------------
   Lighting
---------------------------------------------------------- */
scene.add(new THREE.HemisphereLight(0xd7e8ff, 0xffffff, 1));

const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(5, 7, 10);
scene.add(sun);

/* ----------------------------------------------------------
   Controls
---------------------------------------------------------- */
const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 1.2;

/* ----------------------------------------------------------
   Materials
---------------------------------------------------------- */
const objectMat = new THREE.MeshPhysicalMaterial({
  color: 0x99c5ff,
  roughness: 0.18,
  metalness: 0,
  clearcoat: 1,
  clearcoatRoughness: 0,
  transmission: 0.1,
  thickness: 1
});

/* ----------------------------------------------------------
   Ring (Single Clean Ring)
---------------------------------------------------------- */
const ring = new THREE.Mesh(
  new THREE.TorusGeometry(3, 0.18, 32, 120),
  new THREE.MeshPhysicalMaterial({
    color: 0xf7f1ff,
    roughness: 0.55,
    metalness: 0,
    transmission: 0.6,
    thickness: 1,
    clearcoat: 1,
    clearcoatRoughness: 0.35
  })
);
scene.add(ring);

/* ----------------------------------------------------------
   Object: Box + Knot (We swap visibility)
---------------------------------------------------------- */
const box = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), objectMat.clone());
const knot = new THREE.Mesh(new THREE.TorusKnotGeometry(0.65, 0.27, 120, 22), objectMat.clone());

scene.add(box);
scene.add(knot);

knot.visible = false;

/* ----------------------------------------------------------
   Animation (Move object through the ring)
---------------------------------------------------------- */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const t = clock.getElapsedTime();

  // Move object back & forth
  const z = Math.sin(t) * 3.5;
  box.position.z = knot.position.z = z;

  // Swap object when crossing the center of ring
  if (Math.sin(t) > 0) {
    box.visible = true;
    knot.visible = false;
  } else {
    box.visible = false;
    knot.visible = true;
  }

  // Rotate object
  const r = t * 0.6;
  box.rotation.set(r, r * 1.3, r * 0.7);
  knot.rotation.copy(box.rotation);

  // Rotate ring slowly
  ring.rotation.z = t * 0.12;

  controls.update();
  renderer.render(scene, camera);
}

animate();

/* ----------------------------------------------------------
   Resize
---------------------------------------------------------- */
window.addEventListener("resize", () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
});
</script>

</body>
</html>
