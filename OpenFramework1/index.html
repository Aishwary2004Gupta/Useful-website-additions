<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ring Mesh â€” Three.js Version</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #efefef;
        font-family: Arial, sans-serif;
        transition: background 0.3s ease;
      }
      canvas {
        display: block;
      }
      #toggleBtn {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 16px;
        background: transparent;
        color: #000;
        border: none;
        border-radius: 0;
        cursor: pointer;
        z-index: 100;
        transition: all 0.3s ease;
        padding: 0;
        font-weight: bold;
      }
      #toggleBtn:hover {
        opacity: 0.7;
        transform: scale(1.05);
      }
      body.dark-mode #toggleBtn {
        color: #fff;
      }
      body.dark-mode #toggleBtn:hover {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <button id="toggleBtn">[ Light ]</button>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      ///////////////////////////////////////////////////////////////////////////
      // SCENE SETUP
      ///////////////////////////////////////////////////////////////////////////
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      const camera = new THREE.PerspectiveCamera(
        80,
        innerWidth / innerHeight,
        0.1,
        3000
      );
      camera.position.set(0, -300, 600);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Dark mode state - set to true by default
      let isDarkMode = true;
      
      // Apply dark mode on startup
      document.body.classList.add('dark-mode');

      ///////////////////////////////////////////////////////////////////////////
      // MATERIALS
      ///////////////////////////////////////////////////////////////////////////
      const faceMat = new THREE.MeshBasicMaterial({ color: 0xefefef });
      const frameMat = new THREE.LineBasicMaterial({ color: 0x272727 });
      
      // Dark mode materials
      const faceMat_dark = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
      const frameMat_dark = new THREE.LineBasicMaterial({ color: 0xefefef });

      ///////////////////////////////////////////////////////////////////////////
      // GROUP TO HOLD EVERYTHING
      ///////////////////////////////////////////////////////////////////////////
      const root = new THREE.Group();
      const innerLoopGroup = new THREE.Group();
      const outerLoopGroup = new THREE.Group();
      root.add(innerLoopGroup);
      root.add(outerLoopGroup);
      scene.add(root);

      ///////////////////////////////////////////////////////////////////////////
      // RING GEOMETRY MAKER (Three.js version of setRingToMesh)
      ///////////////////////////////////////////////////////////////////////////
      function createRingMesh(
        position,
        radius,
        width,
        height,
        degStart,
        degEnd
      ) {
        const faceGeom = new THREE.BufferGeometry();
        const frameGeom = new THREE.BufferGeometry();

        const faceVerts = [];
        const faceIndices = [];

        const frameVerts = [];
        const frameIndices = [];

        let idx = 0;
        let fidx = 0;

        for (let deg = degStart; deg <= degEnd; deg++) {
          const deg2 = deg + 1;
          const rad = Math.PI / 180;

          const v = [];

          // Outer ring
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg * rad),
              (radius + width / 2) * Math.sin(deg * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg2 * rad),
              (radius + width / 2) * Math.sin(deg2 * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg2 * rad),
              (radius + width / 2) * Math.sin(deg2 * rad),
              height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg * rad),
              (radius + width / 2) * Math.sin(deg * rad),
              height / 2
            )
          );

          // Inner ring
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg * rad),
              (radius - width / 2) * Math.sin(deg * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg2 * rad),
              (radius - width / 2) * Math.sin(deg2 * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg2 * rad),
              (radius - width / 2) * Math.sin(deg2 * rad),
              height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg * rad),
              (radius - width / 2) * Math.sin(deg * rad),
              height / 2
            )
          );

          // Shift by given location
          v.forEach((p) => p.add(position));

          // Add vertices
          v.forEach((p) => {
            faceVerts.push(p.x, p.y, p.z);
            frameVerts.push(p.x, p.y, p.z);
          });

          // Face indices
          faceIndices.push(
            idx + 0,
            idx + 1,
            idx + 2,
            idx + 0,
            idx + 2,
            idx + 3,
            idx + 4,
            idx + 5,
            idx + 6,
            idx + 4,
            idx + 6,
            idx + 7,

            idx + 0,
            idx + 4,
            idx + 5,
            idx + 0,
            idx + 5,
            idx + 1,
            idx + 3,
            idx + 7,
            idx + 6,
            idx + 3,
            idx + 6,
            idx + 2
          );

          // Frame edges
          frameIndices.push(
            fidx + 0,
            fidx + 1,
            fidx + 2,
            fidx + 3,
            fidx + 4,
            fidx + 5,
            fidx + 6,
            fidx + 7
          );

          idx += 8;
          fidx += 8;
        }

        // Build THREE.js geometry objects
        faceGeom.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(faceVerts, 3)
        );
        faceGeom.setIndex(faceIndices);

        frameGeom.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(frameVerts, 3)
        );
        frameGeom.setIndex(frameIndices);

        return {
          face: new THREE.Mesh(faceGeom, isDarkMode ? faceMat_dark : faceMat),
          frame: new THREE.LineSegments(frameGeom, isDarkMode ? frameMat_dark : frameMat),
        };
      }

      ///////////////////////////////////////////////////////////////////////////
      // BUILD SCENE CONTENT
      ///////////////////////////////////////////////////////////////////////////
      function buildScene() {
        const frameNum = performance.now() * 0.06;
        
        innerLoopGroup.clear();
        outerLoopGroup.clear();

        for (let z = -600; z <= 600; z += 20) {
          for (let radius of [150, 300]) {
            const degStart = frameNum + z + 600 + (radius === 300 ? 180 : 0) + (radius === 150 ? -frameNum * 2 : 0);
            const degEnd = degStart + 90;

            const rings = createRingMesh(
              new THREE.Vector3(0, 0, z),
              radius,
              5,
              15,
              degStart,
              degEnd
            );

            if (radius === 150) {
              innerLoopGroup.add(rings.face);
              innerLoopGroup.add(rings.frame);
            } else {
              outerLoopGroup.add(rings.face);
              outerLoopGroup.add(rings.frame);
            }
          }
        }
      }

      // Build scene once on startup
      buildScene();

      ///////////////////////////////////////////////////////////////////////////
      // TOGGLE DARK/LIGHT MODE
      ///////////////////////////////////////////////////////////////////////////
      function toggleDarkMode() {
        isDarkMode = !isDarkMode;
        const btn = document.getElementById('toggleBtn');
        btn.textContent = isDarkMode ? '[ Light ]' : '[ Dark ]';
        
        if (isDarkMode) {
          document.body.classList.add('dark-mode');
          scene.background.setHex(0x1a1a1a);
        } else {
          document.body.classList.remove('dark-mode');
          scene.background.setHex(0xefefef);
        }
      }

      document.getElementById('toggleBtn').addEventListener('click', toggleDarkMode);

      ///////////////////////////////////////////////////////////////////////////
      // ANIMATION LOOP
      ///////////////////////////////////////////////////////////////////////////
      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001; // seconds

        buildScene();

        // Move inner and outer loops up/down (translate along Y) without changing ring positions
        // inner: moves up/down with smaller amplitude, outer: moves opposite with larger amplitude
        const innerAmplitude = 8; // pixels
        const outerAmplitude = 12; // pixels
        const innerSpeed = 2.0; // Hz
        const outerSpeed = 2.5; // Hz

        // inner moves upward (positive y) following sine; outer moves opposite (negative y)
        innerLoopGroup.position.y = -Math.sin(time * innerSpeed) * innerAmplitude;
        outerLoopGroup.position.y = -Math.sin(time * outerSpeed) * outerAmplitude;

        // keep overall scene orientation
        root.rotation.x = Math.PI + 200;

        renderer.render(scene, camera);
      }

      animate();

      ///////////////////////////////////////////////////////////////////////////
      // RESIZE
      ///////////////////////////////////////////////////////////////////////////
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
