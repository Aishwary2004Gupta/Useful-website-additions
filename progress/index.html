<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HD Depixelation Effect</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: sans-serif;
        overflow: hidden;
      }

      .viewer {
        position: relative;
        background: #111;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
        display: inline-block;
        max-width: 100vw;
        max-height: 100vh;
      }

      .viewer canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui {
        position: absolute;
        bottom: 16px;
        left: 16px;
        right: 16px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px 12px;
        border-radius: 10px;
        color: white;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      #progress {
        width: 100%;
        height: 4px;
        -webkit-appearance: none;
        background: #444;
        border-radius: 2px;
        outline: none;
      }

      #progress::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #74b7ff;
        cursor: pointer;
      }
    </style>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div class="viewer" id="viewer">
      <div id="ui">
        <label for="progress">HD Depixelation Progress</label>
        <input
          id="progress"
          type="range"
          min="0"
          max="1"
          step="0.001"
          value="0"
        />
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

      const container = document.getElementById("viewer");

      /* -------------------------------------
       ENHANCED HD SHADER
    ------------------------------------- */
      const HDDepixelShader = {
        uniforms: {
          tDiffuse: { value: null },
          progress: { value: 0.0 },
          resolution: { value: new THREE.Vector2() },
          time: { value: 0.0 },
        },

        vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,

        fragmentShader: `
        precision highp float;

        uniform sampler2D tDiffuse;
        uniform float progress;
        uniform vec2 resolution;
        uniform float time;
        varying vec2 vUv;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        const float LEVELS = 8.0; // Increased levels for smoother transition

        void main() {
          vec2 uv = vUv;
          
          // Ensure we're sampling at full resolution when progress is 1.0
          if (progress >= 0.999) {
            gl_FragColor = texture2D(tDiffuse, uv);
            return;
          }

          float basePixelSize = pow(2.0, LEVELS);
          float currentLevel = floor(progress * LEVELS);
          
          // Calculate current pixel size for this level
          float currentPixelSize = max(basePixelSize / pow(2.0, currentLevel), 1.0);
          
          // Calculate pixel grid dimensions
          float currentPixelsPerRow = ceil(resolution.x / currentPixelSize);
          float currentPixelsPerCol = ceil(resolution.y / currentPixelSize);
          
          // Total pixels in current level
          float currentTotalPixels = currentPixelsPerRow * currentPixelsPerCol;
          
          // Progress within current level
          float levelProgress = fract(progress * LEVELS);
          
          // Calculate current pixel being processed
          float currentPixelIndex = levelProgress * currentTotalPixels;
          float currentRow = floor(currentPixelIndex / currentPixelsPerRow);
          float currentCol = mod(currentPixelIndex, currentPixelsPerRow);
          
          // Current pixel's grid position
          vec2 gridPos = floor(uv * resolution / currentPixelSize);
          float row = currentPixelsPerCol - gridPos.y - 1.0;
          float col = gridPos.x;
          
          // Determine if this pixel should be depixelated yet
          bool shouldDepixelate = false;
          if (row < currentRow) {
            shouldDepixelate = true;
          } else if (row == currentRow && col <= currentCol) {
            shouldDepixelate = true;
          }
          
          vec4 color;
          
          if (shouldDepixelate) {
            // Depixelated (higher resolution)
            if (currentLevel > 0.0) {
              // For pixels that have been processed, use half the pixel size
              float prevPixelSize = max(basePixelSize / pow(2.0, currentLevel - 1.0), 1.0);
              vec2 pix = prevPixelSize / resolution;
              vec2 depixelatedUv = pix * floor(uv / pix);
              color = texture2D(tDiffuse, depixelatedUv);
            } else {
              // At level 0, use full resolution
              color = texture2D(tDiffuse, uv);
            }
          } else {
            // Still pixelated
            vec2 pix = currentPixelSize / resolution;
            vec2 pixelatedUv = pix * floor(uv / pix);
            color = texture2D(tDiffuse, pixelatedUv);
            
            // Add subtle animation for pixels about to be depixelated
            if (row == currentRow && col == floor(currentCol) + 1.0) {
              float r = random(vec2(col, row));
              float pulse = sin(time * 8.0 + r * 6.283) * 0.5 + 0.5;
              color.rgb += vec3(0.1, 0.15, 0.2) * pulse * 0.3;
            }
          }
          
          // Smooth transition between pixel sizes
          if (currentPixelSize > 2.0) {
            // Add subtle anti-aliasing at edges
            vec2 subPixel = fract(uv * resolution / currentPixelSize);
            vec2 edge = smoothstep(0.0, 0.1, subPixel) * smoothstep(1.0, 0.9, subPixel);
            float edgeFactor = edge.x * edge.y;
            
            if (shouldDepixelate && currentLevel > 0.0) {
              float prevPixelSize = max(basePixelSize / pow(2.0, currentLevel - 1.0), 1.0);
              vec2 prevPix = prevPixelSize / resolution;
              vec2 prevUv = prevPix * floor(uv / prevPix);
              vec4 prevColor = texture2D(tDiffuse, prevUv);
              
              // Blend between current and previous pixel sizes
              float blend = levelProgress;
              color = mix(prevColor, color, blend);
            }
          }
          
          // Ensure full resolution at the very end
          if (progress > 0.99) {
            float finalBlend = (progress - 0.99) / 0.01;
            vec4 finalColor = texture2D(tDiffuse, uv);
            color = mix(color, finalColor, finalBlend);
          }
          
          gl_FragColor = color;
        }
      `,
      };

      /* -------------------------------------
       RENDERER
    ------------------------------------- */
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
        precision: "highp",
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 500);
      camera.position.set(0, 0, 10);

      /* -------------------------------------
       LOAD HD IMAGE
    ------------------------------------- */
      const textureLoader = new THREE.TextureLoader();
      const tex = textureLoader.load(
        "https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg",
        () => {
          const img = tex.image;
          const imgW = img.naturalWidth || img.width;
          const imgH = img.naturalHeight || img.height;

          console.log(`Loaded HD image: ${imgW}x${imgH}`);

          // Fit image size into viewport with some padding
          const padding = 40;
          const maxW = window.innerWidth - padding;
          const maxH = window.innerHeight - padding;
          const scale = Math.min(maxW / imgW, maxH / imgH, 1);

          const targetW = imgW * scale;
          const targetH = imgH * scale;

          container.style.width = targetW + "px";
          container.style.height = targetH + "px";

          resizeRendererToContainer();

          // Enable texture filtering for better quality
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = true;
          tex.needsUpdate = true;
        }
      );

      tex.colorSpace = THREE.SRGBColorSpace;

      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 1),
        new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
        })
      );
      scene.add(plane);

      /* -------------------------------------
       POSTPROCESSING
    ------------------------------------- */
      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      const shaderPass = new ShaderPass(HDDepixelShader);
      composer.addPass(shaderPass);

      /* -------------------------------------
       RESIZE FUNCTION
    ------------------------------------- */
      function resizeRendererToContainer() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        if (width === 0 || height === 0) return;

        renderer.setSize(width, height, false);
        composer.setSize(width, height);
        shaderPass.uniforms.resolution.value.set(width, height);

        // Update camera for pixel-perfect rendering
        camera.left = -width / 2;
        camera.right = width / 2;
        camera.top = height / 2;
        camera.bottom = -height / 2;
        camera.updateProjectionMatrix();

        // Scale plane to fit container exactly
        plane.scale.set(width, height, 1);
      }

      window.addEventListener("resize", () => {
        const img = tex.image;
        if (!img) return;
        const imgW = img.naturalWidth || img.width;
        const imgH = img.naturalHeight || img.height;

        const padding = 40;
        const maxW = window.innerWidth - padding;
        const maxH = window.innerHeight - padding;
        const scale = Math.min(maxW / imgW, maxH / imgH, 1);

        const targetW = imgW * scale;
        const targetH = imgH * scale;

        container.style.width = targetW + "px";
        container.style.height = targetH + "px";

        resizeRendererToContainer();
      });

      /* -------------------------------------
       ANIMATION
    ------------------------------------- */
      const progressSlider = document.getElementById("progress");
      let smoothProgress = 0,
        targetProgress = 0;

      function damp(current, target, lambda, dt) {
        return current + (target - current) * (1.0 - Math.exp(-lambda * dt));
      }

      let lastTime = 0;
      function animate(time) {
        requestAnimationFrame(animate);

        const t = time * 0.001;
        const dt = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;

        targetProgress = parseFloat(progressSlider.value);
        smoothProgress = damp(smoothProgress, targetProgress, 6.0, dt);

        shaderPass.uniforms.progress.value = smoothProgress;
        shaderPass.uniforms.time.value = t;

        composer.render();
      }

      // Initialize
      resizeRendererToContainer();
      animate(0);

      // Demo auto-animation (optional)
      let autoAnimate = true;
      let animationDirection = 1;
      let animationSpeed = 0.3;

      function autoAnimateProgress() {
        if (!autoAnimate) return;

        let current = parseFloat(progressSlider.value);
        current += animationDirection * animationSpeed * 0.016; // Assuming 60fps

        if (current >= 1.0) {
          current = 1.0;
          animationDirection = -1;
        } else if (current <= 0.0) {
          current = 0.0;
          animationDirection = 1;
        }

        progressSlider.value = current;
      }

      // Update progress in animation loop
      const originalAnimate = animate;
      animate = function (time) {
        autoAnimateProgress();
        originalAnimate(time);
      };
    </script>
  </body>
</html>
