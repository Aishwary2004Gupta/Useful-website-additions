<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ring Mesh â€” Three.js Version</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #efefef;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js";

      ///////////////////////////////////////////////////////////////////////////
      // SCENE SETUP
      ///////////////////////////////////////////////////////////////////////////
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xefefef);

      const camera = new THREE.PerspectiveCamera(
        45,
        innerWidth / innerHeight,
        0.1,
        3000
      );
      camera.position.set(0, -300, 600);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      ///////////////////////////////////////////////////////////////////////////
      // MATERIALS
      ///////////////////////////////////////////////////////////////////////////
      const faceMat = new THREE.MeshBasicMaterial({ color: 0xefefef });
      const frameMat = new THREE.LineBasicMaterial({ color: 0x272727 });

      ///////////////////////////////////////////////////////////////////////////
      // GROUP TO HOLD EVERYTHING
      ///////////////////////////////////////////////////////////////////////////
      const root = new THREE.Group();
      scene.add(root);

      ///////////////////////////////////////////////////////////////////////////
      // RING GEOMETRY MAKER (Three.js version of setRingToMesh)
      ///////////////////////////////////////////////////////////////////////////
      function createRingMesh(
        position,
        radius,
        width,
        height,
        degStart,
        degEnd
      ) {
        const faceGeom = new THREE.BufferGeometry();
        const frameGeom = new THREE.BufferGeometry();

        const faceVerts = [];
        const faceIndices = [];

        const frameVerts = [];
        const frameIndices = [];

        let idx = 0;
        let fidx = 0;

        for (let deg = degStart; deg <= degEnd; deg++) {
          const deg2 = deg + 1;
          const rad = Math.PI / 180;

          const v = [];

          // Outer ring
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg * rad),
              (radius + width / 2) * Math.sin(deg * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg2 * rad),
              (radius + width / 2) * Math.sin(deg2 * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg2 * rad),
              (radius + width / 2) * Math.sin(deg2 * rad),
              height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius + width / 2) * Math.cos(deg * rad),
              (radius + width / 2) * Math.sin(deg * rad),
              height / 2
            )
          );

          // Inner ring
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg * rad),
              (radius - width / 2) * Math.sin(deg * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg2 * rad),
              (radius - width / 2) * Math.sin(deg2 * rad),
              -height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg2 * rad),
              (radius - width / 2) * Math.sin(deg2 * rad),
              height / 2
            )
          );
          v.push(
            new THREE.Vector3(
              (radius - width / 2) * Math.cos(deg * rad),
              (radius - width / 2) * Math.sin(deg * rad),
              height / 2
            )
          );

          // Shift by given location
          v.forEach((p) => p.add(position));

          // Add vertices
          v.forEach((p) => {
            faceVerts.push(p.x, p.y, p.z);
            frameVerts.push(p.x, p.y, p.z);
          });

          // Face indices
          faceIndices.push(
            idx + 0,
            idx + 1,
            idx + 2,
            idx + 0,
            idx + 2,
            idx + 3,
            idx + 4,
            idx + 5,
            idx + 6,
            idx + 4,
            idx + 6,
            idx + 7,

            idx + 0,
            idx + 4,
            idx + 5,
            idx + 0,
            idx + 5,
            idx + 1,
            idx + 3,
            idx + 7,
            idx + 6,
            idx + 3,
            idx + 6,
            idx + 2
          );

          // Frame edges
          frameIndices.push(
            fidx + 0,
            fidx + 1,
            fidx + 2,
            fidx + 3,
            fidx + 4,
            fidx + 5,
            fidx + 6,
            fidx + 7
          );

          idx += 8;
          fidx += 8;
        }

        // Build THREE.js geometry objects
        faceGeom.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(faceVerts, 3)
        );
        faceGeom.setIndex(faceIndices);

        frameGeom.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(frameVerts, 3)
        );
        frameGeom.setIndex(frameIndices);

        return {
          face: new THREE.Mesh(faceGeom, faceMat),
          frame: new THREE.LineSegments(frameGeom, frameMat),
        };
      }

      ///////////////////////////////////////////////////////////////////////////
      // BUILD SCENE CONTENT
      ///////////////////////////////////////////////////////////////////////////
      function buildScene() {
        root.clear();

        const frameNum = performance.now() * 0.06;

        for (let z = -600; z <= 600; z += 20) {
          for (let radius of [150, 300]) {
            const degStart = frameNum + z + 600 + (radius === 300 ? 180 : 0);
            const degEnd = degStart + 90;

            const rings = createRingMesh(
              new THREE.Vector3(0, 0, z),
              radius,
              5,
              15,
              degStart,
              degEnd
            );

            root.add(rings.face);
            root.add(rings.frame);
          }
        }
      }

      ///////////////////////////////////////////////////////////////////////////
      // ANIMATION LOOP
      ///////////////////////////////////////////////////////////////////////////
      function animate() {
        requestAnimationFrame(animate);

        buildScene();
        root.rotation.x = Math.PI * 1.5; // same as ofRotateX(270)

        renderer.render(scene, camera);
      }

      animate();

      ///////////////////////////////////////////////////////////////////////////
      // RESIZE
      ///////////////////////////////////////////////////////////////////////////
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
