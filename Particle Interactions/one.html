<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Text Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: 'Arial Black', sans-serif;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="fluid-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // ============================================
        // FLUID TEXT DISTORTION EFFECT
        // ============================================

        class FluidText {
            constructor() {
                this.container = document.getElementById('container');
                this.canvas = document.getElementById('fluid-canvas');
                
                // Mouse state
                this.mouse = { x: 0.5, y: 0.5 };
                this.targetMouse = { x: 0.5, y: 0.5 };
                this.prevMouse = { x: 0.5, y: 0.5 };
                this.velocity = { x: 0, y: 0 };
                
                // Trail points for fluid effect
                this.trail = [];
                this.trailLength = 20;
                
                this.init();
                this.createTextTexture();
                this.createMesh();
                this.addEventListeners();
                this.animate();
            }
            
            init() {
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Scene & Camera
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                
                // Time
                this.time = 0;
                this.clock = new THREE.Clock();
            }
            
            createTextTexture() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // High resolution for crisp text
                const size = 2048;
                canvas.width = size;
                canvas.height = size;
                
                // Background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, size, size);
                
                // Text styling
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 800px "Arial Black", Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw text
                ctx.fillText('AJ', size / 2, size / 2);
                
                // Create texture
                this.textTexture = new THREE.CanvasTexture(canvas);
                this.textTexture.minFilter = THREE.LinearFilter;
                this.textTexture.magFilter = THREE.LinearFilter;
            }
            
            createMesh() {
                // Vertex Shader
                const vertexShader = `
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `;
                
                // Fragment Shader with fluid distortion
                const fragmentShader = `
                    precision highp float;
                    
                    uniform sampler2D uTexture;
                    uniform vec2 uMouse;
                    uniform vec2 uVelocity;
                    uniform float uTime;
                    uniform float uIntensity;
                    uniform vec2 uResolution;
                    uniform vec3 uTrail[20];
                    
                    varying vec2 vUv;
                    
                    // Simplex 2D noise
                    vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

                    float snoise(vec2 v) {
                        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                           -0.577350269189626, 0.024390243902439);
                        vec2 i  = floor(v + dot(v, C.yy));
                        vec2 x0 = v - i + dot(i, C.xx);
                        vec2 i1;
                        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                        vec4 x12 = x0.xyxy + C.xxzz;
                        x12.xy -= i1;
                        i = mod(i, 289.0);
                        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                                        + i.x + vec3(0.0, i1.x, 1.0));
                        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                                               dot(x12.zw,x12.zw)), 0.0);
                        m = m*m;
                        m = m*m;
                        vec3 x = 2.0 * fract(p * C.www) - 1.0;
                        vec3 h = abs(x) - 0.5;
                        vec3 ox = floor(x + 0.5);
                        vec3 a0 = x - ox;
                        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                        vec3 g;
                        g.x = a0.x * x0.x + h.x * x0.y;
                        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                        return 130.0 * dot(m, g);
                    }
                    
                    void main() {
                        vec2 uv = vUv;
                        float aspect = uResolution.x / uResolution.y;
                        vec2 aspectUV = vec2(uv.x * aspect, uv.y);
                        
                        vec2 totalDistortion = vec2(0.0);
                        
                        // Process trail points for smooth fluid effect
                        for(int i = 0; i < 20; i++) {
                            vec2 trailPos = uTrail[i].xy;
                            float trailStrength = uTrail[i].z;
                            
                            vec2 trailAspect = vec2(trailPos.x * aspect, trailPos.y);
                            vec2 diff = aspectUV - trailAspect;
                            float dist = length(diff);
                            
                            // Fluid radius falloff
                            float radius = 0.15 + trailStrength * 0.1;
                            float strength = smoothstep(radius, 0.0, dist);
                            strength = pow(strength, 1.5);
                            
                            // Add noise for organic movement
                            float noise = snoise(uv * 5.0 + float(i) * 0.5 + uTime * 0.3);
                            
                            // Direction based on velocity
                            vec2 dir = normalize(diff + 0.001);
                            
                            // Distortion with velocity influence
                            vec2 distort = dir * strength * (0.08 + trailStrength * 0.15);
                            distort += vec2(noise * 0.01) * strength;
                            
                            totalDistortion += distort * (1.0 - float(i) / 20.0);
                        }
                        
                        // Main mouse distortion
                        vec2 mouseAspect = vec2(uMouse.x * aspect, uMouse.y);
                        vec2 mouseDiff = aspectUV - mouseAspect;
                        float mouseDist = length(mouseDiff);
                        
                        float mouseRadius = 0.2;
                        float mouseStrength = smoothstep(mouseRadius, 0.0, mouseDist);
                        mouseStrength = pow(mouseStrength, 1.2);
                        
                        // Velocity-based distortion
                        float speed = length(uVelocity);
                        vec2 velocityDistort = uVelocity * mouseStrength * 2.0;
                        
                        // Ripple effect
                        float ripple = sin(mouseDist * 25.0 - uTime * 3.0) * 0.015;
                        ripple *= mouseStrength * speed;
                        
                        vec2 rippleDistort = normalize(mouseDiff + 0.001) * ripple;
                        
                        // Combine all distortions
                        vec2 finalDistort = totalDistortion + velocityDistort + rippleDistort;
                        
                        // Apply distortion to UV
                        vec2 distortedUV = uv - finalDistort;
                        
                        // Sample texture
                        vec4 color = texture2D(uTexture, distortedUV);
                        
                        // Slight chromatic aberration on movement
                        float aberration = speed * 0.003 * mouseStrength;
                        float r = texture2D(uTexture, distortedUV + vec2(aberration, 0.0)).r;
                        float b = texture2D(uTexture, distortedUV - vec2(aberration, 0.0)).b;
                        color.r = r;
                        color.b = b;
                        
                        gl_FragColor = color;
                    }
                `;
                
                // Initialize trail uniform
                const trailUniform = [];
                for (let i = 0; i < 20; i++) {
                    trailUniform.push(new THREE.Vector3(0.5, 0.5, 0));
                }
                
                // Material
                this.material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    uniforms: {
                        uTexture: { value: this.textTexture },
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uVelocity: { value: new THREE.Vector2(0, 0) },
                        uTime: { value: 0 },
                        uIntensity: { value: 1.0 },
                        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        uTrail: { value: trailUniform }
                    }
                });
                
                // Geometry
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                // Mesh
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.scene.add(this.mesh);
            }
            
            addEventListeners() {
                // Mouse move
                window.addEventListener('mousemove', (e) => {
                    this.targetMouse.x = e.clientX / window.innerWidth;
                    this.targetMouse.y = 1.0 - e.clientY / window.innerHeight;
                });
                
                // Touch support
                window.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.targetMouse.x = touch.clientX / window.innerWidth;
                    this.targetMouse.y = 1.0 - touch.clientY / window.innerHeight;
                }, { passive: false });
                
                // Resize
                window.addEventListener('resize', () => {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.material.uniforms.uResolution.value.set(
                        window.innerWidth, 
                        window.innerHeight
                    );
                });
            }
            
            updateMouse() {
                // Store previous position
                this.prevMouse.x = this.mouse.x;
                this.prevMouse.y = this.mouse.y;
                
                // Smooth interpolation
                const ease = 0.15;
                this.mouse.x += (this.targetMouse.x - this.mouse.x) * ease;
                this.mouse.y += (this.targetMouse.y - this.mouse.y) * ease;
                
                // Calculate velocity
                this.velocity.x = this.mouse.x - this.prevMouse.x;
                this.velocity.y = this.mouse.y - this.prevMouse.y;
                
                // Update trail
                const speed = Math.sqrt(
                    this.velocity.x * this.velocity.x + 
                    this.velocity.y * this.velocity.y
                );
                
                // Add new point to trail
                this.trail.unshift({
                    x: this.mouse.x,
                    y: this.mouse.y,
                    strength: Math.min(speed * 10, 1.0)
                });
                
                // Limit trail length
                if (this.trail.length > this.trailLength) {
                    this.trail.pop();
                }
                
                // Update uniforms
                this.material.uniforms.uMouse.value.set(this.mouse.x, this.mouse.y);
                this.material.uniforms.uVelocity.value.set(this.velocity.x, this.velocity.y);
                
                // Update trail uniform
                for (let i = 0; i < this.trailLength; i++) {
                    if (this.trail[i]) {
                        this.material.uniforms.uTrail.value[i].set(
                            this.trail[i].x,
                            this.trail[i].y,
                            this.trail[i].strength
                        );
                    }
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time = this.clock.getElapsedTime();
                this.material.uniforms.uTime.value = this.time;
                
                this.updateMouse();
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            new FluidText();
        });
    </script>
</body>
</html>