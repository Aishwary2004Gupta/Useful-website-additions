<!DOCTYPE html>
<html>
<head>
  <title>PixelTrail - HTML Canvas Gooey Trail</title>
  <style>
    body { background: #181818; margin: 0; overflow: hidden; }
    #pixel-trail-canvas {
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      filter: url(#goo-trail-filter);
      background: #181818;
    }
    .svg-filters { position: absolute; width: 0; height: 0; }
  </style>
</head>
<body>
  <svg class="svg-filters">
    <defs>
      <filter id="goo-trail-filter">
        <feGaussianBlur stdDeviation="8" result="blur" />
        <feColorMatrix in="blur" mode="matrix"
          values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 20 -8"
          result="goo"
        />
        <feComposite in="SourceGraphic" in2="goo" operator="atop"/>
      </filter>
    </defs>
  </svg>
  <canvas id="pixel-trail-canvas"></canvas>
  <script>
    // --- Config ---
    const gridSize = 50;
    const trailRadius = 0.1;
    const maxAge = 250; // ms to fade
    const interpolate = 5; // smoothness
    const trailColor = "#fff";
    const filterStrength = 8; // stdDeviation for GaussianBlur

    // --- Canvas Setup ---
    const canvas = document.getElementById('pixel-trail-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- Data Structures ---
    let trailGrid = [];
    function makeTrailGrid() {
      trailGrid = [];
      for (let x=0; x<gridSize; x++) {
        trailGrid[x]=[];
        for (let y=0; y<gridSize; y++) {
          trailGrid[x][y]=0;
        }
      }
    }
    makeTrailGrid();

    // --- Mouse Trail Logic ---
    let lastMouse = null;
    canvas.addEventListener('mousemove', e => {
      const mx = e.clientX, my = e.clientY;
      lastMouse = [mx, my];
      // Map mouse to grid coordinate
      const gx = Math.floor(mx / canvas.width * gridSize);
      const gy = Math.floor(my / canvas.height * gridSize);
      paintTrail(gx, gy);
      // Interpolate for smooth trail
      for (let i=1;i<=interpolate;i++) {
        if (lastMouse) {
          const ix = Math.floor((lastMouse[0] + (mx-lastMouse[0])*i/interpolate)/canvas.width*gridSize);
          const iy = Math.floor((lastMouse[1] + (my-lastMouse[1])*i/interpolate)/canvas.height*gridSize);
          paintTrail(ix, iy);
        }
      }
    });
    function paintTrail(gx, gy) {
      const r = Math.max(1, Math.floor(trailRadius*gridSize));
      for (let dx=-r; dx<=r; dx++) {
        for (let dy=-r; dy<=r; dy++) {
          const x = gx+dx, y = gy+dy;
          if (x>=0 && x<gridSize && y>=0 && y<gridSize) {
            // Distance check for soft edges
            const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist <= r) {
              trailGrid[x][y] = maxAge;
            }
          }
        }
      }
    }

    // --- Animation Loop ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cellW = canvas.width / gridSize;
      const cellH = canvas.height / gridSize;
      for (let x=0; x<gridSize; x++) {
        for (let y=0; y<gridSize; y++) {
          const age = trailGrid[x][y];
          if (age > 0) {
            ctx.globalAlpha = age / maxAge;
            ctx.fillStyle = trailColor;
            ctx.beginPath();
            ctx.arc(
              x*cellW + cellW/2,
              y*cellH + cellH/2,
              Math.min(cellW, cellH)*0.32,
              0,
              2*Math.PI
            );
            ctx.fill();
            trailGrid[x][y] -= 16; // fade speed
            if (trailGrid[x][y] < 0) trailGrid[x][y] = 0;
          }
        }
      }
      ctx.globalAlpha = 1.0;
      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
