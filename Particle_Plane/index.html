<!-- Create by @aish2004gupta on X -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wave Animation</title>

    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #00000015;
      }

      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .dg {
        z-index: 99999 !important;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
      /* ======================================================
            BASE SETUP
      ====================================================== */
      const scene = new THREE.Scene();
      const canvas = document.querySelector("#canvas");

      const camera = new THREE.PerspectiveCamera(
        65,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(-10, 5, 10);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const clock = new THREE.Clock();
      clock.start();

      scene.add(new THREE.AmbientLight(0xffffff, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(6, 8, 6);
      scene.add(dirLight);

      const particleTexture = new THREE.TextureLoader().load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      /* ======================================================
            PARAMS
      ====================================================== */
      const params = {
        mode: "particles",
        amplitude: 1.2,
        frequency: 1.5,
        speed: 1.2,
        particleCount: 20000,
        particleSize: 0.12,
        width: 14,
        height: 14,
        segments: 140,
        wireframe: true,
        playPause: () => togglePause(),
      };

      /* ======================================================
            DEFAULTS
      ====================================================== */
      function applyParticlesDefaults() {
        params.particleCount = 20000;
        params.particleSize = 0.12;
        params.width = 14;
        params.height = 14;
      }

      function applySurfaceDefaults() {
        params.segments = 140;
        params.width = 14;
        params.height = 14;
      }

      /* ======================================================
            PAUSE / PLAY
      ====================================================== */
      let paused = false;
      let savedTime = 0;
      let playPauseController;

      function togglePause() {
        if (!paused) {
          savedTime += clock.getElapsedTime();
          clock.stop();
          paused = true;
          playPauseController.name("‚ñ∂ Play");
        } else {
          clock.start();
          paused = false;
          playPauseController.name("‚è∏ Pause");
        }
      }

      /* ======================================================
            SCENE OBJECTS
      ====================================================== */
      let points = null;
      let surface = null;
      let wireframeMesh = null;

      function disposeObjects() {
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        if (surface) {
          scene.remove(surface);
          surface.geometry.dispose();
          surface.material.dispose();
          surface = null;
        }
        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMesh.geometry.dispose();
          wireframeMesh.material.dispose();
          wireframeMesh = null;
        }
      }

      function heightToColor(t) {
        t = THREE.MathUtils.clamp(t, 0, 1);
        const c = new THREE.Color();

        if (t < 0.33) c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
        else if (t < 0.66) {
          const tt = (t - 0.33) / 0.33;
          c.setRGB(tt * 0.4, 0.9, tt * 0.6);
        } else {
          const tt = (t - 0.66) / 0.34;
          c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
        }

        return c;
      }

      /* ======================================================
            WAVE APPLY HELPERS
      ====================================================== */
      function applyWaveToGeometry(geometry, t) {
        const pos = geometry.attributes.position.array;
        const yOffset = 1.2;

        for (let i = 0; i < pos.length; i += 3) {
          const x = pos[i];
          const z = pos[i + 2];

          pos[i + 1] =
            Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude +
            yOffset;
        }

        geometry.attributes.position.needsUpdate = true;
      }

      function applyColorToGeometry(geometry) {
        const pos = geometry.attributes.position.array;
        const col = geometry.attributes.color.array;

        let min = Infinity,
          max = -Infinity;

        for (let i = 0; i < pos.length; i += 3) {
          min = Math.min(min, pos[i + 1]);
          max = Math.max(max, pos[i + 1]);
        }

        const range = max - min || 1;

        for (let i = 0; i < pos.length; i += 3) {
          const t = (pos[i + 1] - min) / range;
          const c = heightToColor(t);
          col.set([c.r, c.g, c.b], i);
        }

        geometry.attributes.color.needsUpdate = true;
      }

      /* ======================================================
            CREATE PARTICLES (initializes to current t to avoid jumps)
      ====================================================== */
      function createParticles() {
        disposeObjects();

        const count = Math.max(1000, Math.min(50000, Math.round(params.particleCount)));
        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const idx = i * 3;
          positions[idx] = (Math.random() - 0.5) * params.width;
          positions[idx + 1] = 0;
          positions[idx + 2] = (Math.random() - 0.5) * params.height;

          const c = new THREE.Color().setHSL(Math.random(), 0.6, 0.55);
          colors.set([c.r, c.g, c.b], idx);
        }

        geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // initialize geometry to current wave shape (preserves phase/time)
        const t = savedTime * params.speed;
        applyWaveToGeometry(geometry, t);

        points = new THREE.Points(
          geometry,
          new THREE.PointsMaterial({
            size: params.particleSize,
            vertexColors: true,
            alphaMap: particleTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );

        scene.add(points);
      }

      /* ======================================================
            CREATE SURFACE (initializes to current t to avoid jumps)
      ====================================================== */
      function createSurface() {
        disposeObjects();

        const seg = Math.max(4, Math.min(600, Math.round(params.segments)));
        const geometry = new THREE.PlaneBufferGeometry(
          params.width,
          params.height,
          seg,
          seg
        );
        geometry.rotateX(-Math.PI / 2);

        const colors = new Float32Array(geometry.attributes.position.count * 3);
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // initialize geometry to current wave shape (preserves phase/time)
        const t = savedTime * params.speed;
        applyWaveToGeometry(geometry, t);
        applyColorToGeometry(geometry);

        surface = new THREE.Mesh(
          geometry,
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 45,
            side: THREE.DoubleSide,
          })
        );

        scene.add(surface);

        if (params.wireframe) {
          wireframeMesh = new THREE.LineSegments(
            new THREE.WireframeGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0x101010 })
          );
          scene.add(wireframeMesh);
        }
      }

      /* ======================================================
            REAL-TIME WAVE UPDATE WHILE PAUSED
      ====================================================== */
      function updateWaveWhilePaused() {
        if (!paused) return;

        const t = savedTime * params.speed;

        if (points) applyWaveToGeometry(points.geometry, t);

        if (surface) {
          applyWaveToGeometry(surface.geometry, t);
          applyColorToGeometry(surface.geometry);

          if (wireframeMesh) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(surface.geometry);
          }
        }
      }

      /* ======================================================
            REBUILD (preserve wave shape/time)
      ====================================================== */
      function rebuild() {
        // createParticles/createSurface initialize geometry to current t so no jump
        if (params.mode === "particles") createParticles();
        else createSurface();
      }

      /* ======================================================
            GUI SETUP
      ====================================================== */
      const gui = new dat.GUI({ width: 300 });
      gui.close();

      playPauseController = gui.add(params, "playPause").name("‚è∏ Pause");

      gui
        .add(params, "mode", ["particles", "surface"])
        .name("Display Mode")
        .onChange(() => rebuild());

      /* PARTICLE SETTINGS */
      const particlesFolder = gui.addFolder("‚ú® Particle Settings");
      // count - update immediately while preserving wave/time
      particlesFolder
        .add(params, "particleCount", 1000, 50000, 1000)
        .name("Count")
        .onChange(() => {
          // rebuild using current t so shape preserved
          rebuild();
        });
      particlesFolder
        .add(params, "particleSize", 0.01, 0.5, 0.01)
        .name("Size")
        .onChange(() => points && (points.material.size = params.particleSize));
      // area X/Z: rebuild immediately
      particlesFolder
        .add(params, "width", 2, 40, 0.5)
        .name("Wave Area X")
        .onChange(() => rebuild());
      particlesFolder
        .add(params, "height", 2, 40, 0.5)
        .name("Wave Area Z")
        .onChange(() => rebuild());
      particlesFolder.close();

      /* SURFACE SETTINGS */
      const surfaceFolder = gui.addFolder("üåä Surface Settings");
      // resolution (segments) - update immediately while preserving wave/time
      surfaceFolder
        .add(params, "segments", 4, 300, 1)
        .name("Resolution")
        .onChange(() => {
          rebuild();
        });
      surfaceFolder
        .add(params, "width", 2, 40, 0.5)
        .name("Wave Area X")
        .onChange(() => rebuild());
      surfaceFolder
        .add(params, "height", 2, 40, 0.5)
        .name("Wave Area Z")
        .onChange(() => rebuild());
      surfaceFolder
        .add(params, "wireframe")
        .name("Wireframe")
        .onChange(() => rebuild());
      surfaceFolder.close();

      /* WAVE CONTROLS (update in real-time, also while paused) */
      const wavesFolder = gui.addFolder("üéõ Wave Controls");
      wavesFolder
        .add(params, "amplitude", 0, 3, 0.01)
        .name("Wave Height")
        .onChange(updateWaveWhilePaused);
      wavesFolder
        .add(params, "frequency", 0, 6, 0.01)
        .name("Frequency")
        .onChange(updateWaveWhilePaused);
      wavesFolder
        .add(params, "speed", 0, 3, 0.01)
        .name("Speed")
        .onChange(updateWaveWhilePaused);
      wavesFolder.close();

      /* initialize */
      applyParticlesDefaults();
      rebuild();

      /* ======================================================
            ANIMATION LOOP
      ====================================================== */
      function animate() {
        requestAnimationFrame(animate);

        if (!paused) savedTime += clock.getDelta();

        const t = savedTime * params.speed;
        const yOffset = 1.2;

        /* PARTICLES UPDATE (animated frames) */
        if (!paused && points) {
          const pos = points.geometry.attributes.position.array;
          for (let i = 0; i < pos.length; i += 3) {
            const x = pos[i];
            const z = pos[i + 2];
            pos[i + 1] =
              Math.sin((x * 0.5 + t) * params.frequency) *
                Math.cos((z * 0.5 + t) * params.frequency) *
                params.amplitude +
              yOffset;
          }
          points.geometry.attributes.position.needsUpdate = true;
        }

        /* SURFACE UPDATE (animated frames) */
        if (!paused && surface) {
          const pos = surface.geometry.attributes.position.array;
          let min = Infinity,
            max = -Infinity;

          for (let i = 0; i < pos.length; i += 3) {
            const x = pos[i];
            const z = pos[i + 2];

            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
                Math.cos((z * 0.5 + t) * params.frequency) *
                params.amplitude +
              yOffset;

            pos[i + 1] = y;
            min = Math.min(min, y);
            max = Math.max(max, y);
          }

          const col = surface.geometry.attributes.color.array;
          const range = max - min || 1;

          for (let i = 0; i < pos.length; i += 3) {
            const y = pos[i + 1];
            const tt = (y - min) / range;
            const c = heightToColor(tt);
            col.set([c.r, c.g, c.b], i);
          }

          surface.geometry.attributes.position.needsUpdate = true;
          surface.geometry.attributes.color.needsUpdate = true;

          if (wireframeMesh) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(surface.geometry);
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      /* ======================================================
            RESIZE HANDLING
      ====================================================== */
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
