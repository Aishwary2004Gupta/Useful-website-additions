<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Jelly Switch â€“ Three.js port</title>
    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      const canvas = document.querySelector("canvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
      let quality = 0.5;
      let w = innerWidth * quality;
      let h = innerHeight * quality;
      renderer.setSize(w, h);

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const persp = new THREE.PerspectiveCamera(
        (45 * Math.PI) / 180,
        w / h,
        0.1,
        10
      );
      persp.position.set(0.024, 2.7, 1.9);
      persp.lookAt(0, 0, 0);

      const uniforms = {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(w, h) },
        u_viewMatrix: { value: new THREE.Matrix4() },
        u_projMatrix: { value: new THREE.Matrix4() },
        u_viewInvMatrix: { value: new THREE.Matrix4() },
        u_projInvMatrix: { value: new THREE.Matrix4() },
        u_cameraPosition: { value: new THREE.Vector3() },
        u_lightDir: { value: new THREE.Vector3(0.19, -0.24, 0.75).normalize() },
        u_lightColor: { value: new THREE.Vector3(1, 1, 1) },
        u_jellyColor: { value: new THREE.Vector3(1, 0.45, 0.075) },
        u_darkMode: { value: 0 },
        u_random: { value: new THREE.Vector2() },
        u_switchState: { value: new THREE.Vector4(0, 0, 0, 0) },
      };

      const mat = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.);}`,
        fragmentShader: `
precision highp float;
varying vec2 vUv;
uniform vec2 u_resolution;
uniform mat4 u_viewMatrix,u_projMatrix,u_viewInvMatrix,u_projInvMatrix;
uniform vec3 u_cameraPosition,u_lightDir,u_lightColor,u_jellyColor;
uniform float u_darkMode;
uniform vec2 u_random;
uniform vec4 u_switchState;

#define MAX_STEPS 64
#define MAX_DIST 10.
#define SURF_DIST .001
#define JELLY_HALFSIZE vec3(.35,.3,.3)
#define SWITCH_RAIL_LENGTH .4
#define JELLY_IOR 1.42
#define JELLY_SCATTER_STRENGTH 3.
#define AO_STEPS 3
#define AO_RADIUS .1
#define AO_INTENSITY .5
#define AO_BIAS .005
#define AMBIENT_COLOR vec3(.6)
#define AMBIENT_INTENSITY .6
#define SPECULAR_POWER 10.
#define SPECULAR_INTENSITY .6
#define LIGHT_GROUND vec3(1.)
#define DARK_GROUND vec3(.2)

const float groundThick=.03,groundR=.05,groundRound=.02;

float sdPlane(vec3 p,vec3 n,float h){return dot(p,n)+h;}
float sdRoundBox2(vec2 p,vec2 b,float r){
  vec2 q=abs(p)-b+r;
  return min(max(q.x,q.y),0.)+length(max(q,0.))-r;
}
float sdRoundBox3(vec3 p,vec3 b,float r){
  vec3 q=abs(p)-b+r;
  return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.))-r;
}
float opU(float a,float b){return min(a,b);}
float opExtrudeY(vec3 p,float d,float h){
  vec2 w=vec2(d,abs(p.y)-h);
  return min(max(w.x,w.y),0.)+length(max(w,0.));
}
vec3 opCheapBend(vec3 p,float k){
  float c=cos(k*p.x),s=sin(k*p.x);
  return vec3(mat2(c,-s,s,c)*p.xy,p.z);
}
vec3 opRotAxis(vec3 p,vec3 axis,float ang){
  float s=sin(ang),c=cos(ang),t=dot(axis,p);
  return mix(axis*t,p,c)+cross(axis,p)*s;
}

float rectCut(vec2 p){
  return sdRoundBox2(p,vec2(SWITCH_RAIL_LENGTH*.5+.2+groundRound,groundR+groundRound),groundR+groundRound);
}
float mainSD(vec3 p){
  return opU(sdPlane(p,vec3(0,1,0),.06),
             opExtrudeY(p,-rectCut(p.xz),groundThick-groundRound)-groundRound);
}
float jellySD(vec3 p){
  vec4 st=u_switchState;
  vec3 off=vec3((st.x-.5)*SWITCH_RAIL_LENGTH-st.y*(st.x-.5)*.2,
                JELLY_HALFSIZE.y*.5,0.);
  vec3 sc=vec3(1.-st.y,1.,1.-st.z);
  vec3 local=opRotAxis((p-off)*sc,vec3(0,0,1),st.w);
  return sdRoundBox3(opCheapBend(local,.8),JELLY_HALFSIZE-.1,.1);
}
vec2 map(vec3 p){
  float m=mainSD(p),j=jellySD(p);
  return j<m?vec2(j,1.):vec2(m,0.);
}
float mapAO(vec3 p){return min(mainSD(p),jellySD(p));}

vec3 normal(vec3 p,float e){
  float d=map(p).x;
  return normalize(vec3(map(p+vec3(e,0,0)).x-d,
                        map(p+vec3(0,e,0)).x-d,
                        map(p+vec3(0,0,e)).x-d));
}
vec3 getNormal(vec3 p){
  return (abs(p.z)>.5||abs(p.x)>1.02)?vec3(0,1,0):normal(p,.0001);
}

float sdShadow(vec3 p,vec3 ldir){
  if(p.y<-groundThick){
    float f=30.,inset=.02;
    float cut=rectCut(p.xz)+inset;
    float edge=clamp(1.-cut*f,0.,1.);
    float grad=clamp(-p.z*4.*ldir.z+1.,0.,1.);
    return edge*grad*.5;
  }
  return 1.;
}
float calcAO(vec3 p,vec3 n){
  float occ=0.,w=1.;
  float step=AO_RADIUS/float(AO_STEPS);
  for(int i=1;i<=AO_STEPS;i++){
    float h=step*float(i);
    vec3 s=p+n*h;
    float d=mapAO(s)-AO_BIAS;
    occ+=max(0.,h-d)*w;
    w*=.5;
    if(occ>AO_RADIUS/AO_INTENSITY)break;
  }
  return clamp(1.-AO_INTENSITY*occ/AO_RADIUS,0.,1.);
}
vec3 lighting(vec3 p,vec3 n,vec3 ro){
  vec3 ldir=-u_lightDir;
  float diff=max(dot(n,ldir),0.);
  vec3 v=normalize(ro-p);
  vec3 r=reflect(-ldir,n);
  float spec=pow(max(dot(v,r),0.),SPECULAR_POWER)*SPECULAR_INTENSITY;
  vec3 base=vec3(.9);
  vec3 col=base*u_lightColor*diff*sdShadow(p,ldir)+
            base*AMBIENT_COLOR*AMBIENT_INTENSITY+
            u_lightColor*spec*sdShadow(p,ldir);
  return clamp(col,0.,1.);
}
vec4 applyAO(vec3 col,vec3 p,vec3 n){
  return vec4(col*calcAO(p,n),1.);
}

vec4 bg(vec3 ro,vec3 rd,float t){
  vec4 st=u_switchState;
  vec3 p=ro+rd*t;
  vec3 n=getNormal(p);
  vec3 base=mix(LIGHT_GROUND,DARK_GROUND,u_darkMode);
  float sx=(st.x-.5)*SWITCH_RAIL_LENGTH;
  float d2=length(p-vec3(sx,0,0));
  vec3 bounce=u_jellyColor*(1./(d2*d2*15.+1.)*.4);
  vec3 side=u_jellyColor*(1./(d2*d2*40.+1.)*.3*abs(n.z));
  float e=smoothstep(.7,1.,st.x)*2.+.7;
  vec3 lit=lighting(p,n,ro);
  vec4 c=applyAO(base*lit,p,n);
  c.xyz+=bounce*e+side*e;
  return c;
}
vec3 marchNoJelly(vec3 ro,vec3 rd){
  float t=0.;
  for(int i=0;i<6;i++){
    float d=mainSD(ro+rd*t);
    t+=d;
    if(t>MAX_DIST||d<SURF_DIST*10.)break;
  }
  return t<MAX_DIST?bg(ro,rd,t).xyz:vec3(0);
}
vec4 march(vec3 ro,vec3 rd){
  float t=0.;
  for(int i=0;i<MAX_STEPS;i++){
    float d=mainSD(ro+rd*t);
    t+=d;
    if(d<SURF_DIST)break;
  }
  vec4 c=bg(ro,rd,t);

  vec3 bmin=vec3(-1),bmax=vec3(1);
  vec3 inv=1./rd;
  vec3 t1=(bmin-ro)*inv,t2=(bmax-ro)*inv;
  vec3 mn=min(t1,t2),mx=max(t1,t2);
  float tmin=max(max(mn.x,mn.y),mn.z);
  float tmax=min(min(mx.x,mx.y),mx.z);
  if(tmax<tmin||tmax<0.)return c;

  t=max(0.,tmin);
  for(int i=0;i<MAX_STEPS;i++){
    vec2 h=map(ro+rd*t);
    t+=h.x;
    if(h.x<SURF_DIST){
      if(h.y<.5)break;
      vec3 p=ro+rd*t;
      vec3 N=getNormal(p);
      vec3 I=rd;
      float cosi=min(1.,max(0.,dot(-I,N)));
      float F=fresnelSchlick(cosi,1.,JELLY_IOR);
      vec3 refl=clamp(vec3(p.y+.2),0.,1.);
      float k=1.-(1./JELLY_IOR/JELLY_IOR)*(1.-cosi*cosi);
      vec3 refrCol=vec3(0);
      if(k>0.){
        vec3 R=normalize(I/JELLY_IOR+N*(cosi/JELLY_IOR-sqrt(k)));
        vec3 exit=p+R*SURF_DIST*4.;
        vec3 env=marchNoJelly(exit,R);
        vec3 absorb=(vec3(1.)-u_jellyColor)*20.;
        float pr=clamp(mix(1.,.6,p.y/(JELLY_HALFSIZE.y*2.)+.25),0.,1.)*u_switchState.x;
        vec3 T=beerLambert(absorb*(pr*pr),.08);
        float fwd=max(0.,dot(-u_lightDir,R));
        vec3 sc=u_jellyColor*1.5*JELLY_SCATTER_STRENGTH*fwd*pow(pr,3.);
        refrCol=env*T+sc;
      }
      return vec4(mix(refrCol,refl,F),1.);
    }
    if(t>MAX_DIST)break;
  }
  return c;
}
vec3 getRayDir(vec2 ndc){
  vec4 clip=vec4(ndc,-1.,1.);
  vec4 view=u_projInvMatrix*clip;view/=view.w;
  vec4 world=u_viewInvMatrix*view;
  return normalize(world.xyz-u_cameraPosition);
}
void main(){
  vec2 uv=vUv;
  vec2 ndc=vec2(uv*2.-1.);ndc.y*=-1.;
  vec3 ro=u_cameraPosition;
  vec3 rd=getRayDir(ndc);
  vec4 col=march(ro,rd);
  float exposure=mix(1.5,2.,u_darkMode);
  col.xyz=tanh(col.xyz*exposure);
  gl_FragColor=col;
}
`,
      });

      scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat));

      // ----------  simple spring + switch logic ----------
      class Spring {
        constructor(cfg) {
          Object.assign(this, { target: 0, value: 0, vel: 0 }, cfg);
        }
        update(dt) {
          const f =
            -this.stiff * (this.value - this.target) - this.damp * this.vel;
          this.vel += (f / this.mass) * dt;
          this.value += this.vel * dt;
        }
      }
      const SWITCH_ACC = 100;
      const sprX = new Spring({ mass: 1, stiff: 1000, damp: 10 });
      const sprZ = new Spring({ mass: 1, stiff: 900, damp: 12 });
      const sprW = new Spring({ mass: 1, stiff: 1000, damp: 20 });

      class Switch {
        _t = false;
        _p = 0;
        _v = 0;
        _prs = false;
        update(dt) {
          if (dt <= 0) return;
          let acc = 0;
          if (this._t && this._p < 1) acc = SWITCH_ACC;
          if (!this._t && this._p > 0) acc = -SWITCH_ACC;
          if (this._prs) {
            sprX.vel = -2;
            sprZ.vel = 1;
            sprW.vel = Math.sign(this._p - 0.5);
          }
          this._v += acc * dt;
          if (this._p > 0 && this._p < 1) sprW.vel = this._v;
          this._p += this._v * dt;
          if (this._p > 1) {
            this._p = 1;
            this._v = 0;
            sprX.vel = -5;
            sprZ.vel = 5;
            sprW.vel = -10;
          }
          if (this._p < 0) {
            this._p = 0;
            this._v = 0;
            sprX.vel = -5;
            sprZ.vel = 5;
            sprW.vel = 10;
          }
          this._p = clamp(this._p, 0, 1);
          sprX.update(dt);
          sprZ.update(dt);
          sprW.update(dt);
          uniforms.u_switchState.value.set(
            this._p,
            sprX.value,
            sprZ.value,
            sprW.value
          );
        }
        get pressed() {
          return this._prs;
        }
        set pressed(v) {
          this._prs = v;
        }
        get toggled() {
          return this._t;
        }
        set toggled(v) {
          this._t = v;
        }
      }
      const sw = new Switch();

      // ----------  events ----------
      ["mousedown", "touchstart"].forEach((ev) =>
        canvas.addEventListener(ev, (e) => {
          sw.pressed = true;
          e.preventDefault();
        })
      );
      ["mouseup", "touchend"].forEach((ev) =>
        canvas.addEventListener(ev, (e) => {
          sw.pressed = false;
          sw.toggled = !sw.toggled;
          e.preventDefault();
        })
      );
      window.addEventListener("mouseup", () => (sw.pressed = false));

      // ----------  render loop ----------
      let last = 0;
      function loop(t) {
        requestAnimationFrame(loop);
        const dt = Math.min((t - last) * 0.001, 0.1);
        last = t;
        uniforms.u_time.value = t * 0.001;
        sw.update(dt);
        uniforms.u_random.value.set(Math.random() - 0.5, Math.random() - 0.5);
        persp.updateMatrixWorld();
        uniforms.u_viewMatrix.value.copy(persp.matrixWorldInverse);
        uniforms.u_projMatrix.value.copy(persp.projectionMatrix);
        uniforms.u_viewInvMatrix.value.copy(persp.matrixWorld);
        uniforms.u_projInvMatrix.value.copy(persp.projectionMatrix).invert();
        uniforms.u_cameraPosition.value.copy(persp.position);
        renderer.render(scene, camera);
      }
      loop(0);

      // ----------  resize ----------
      window.addEventListener("resize", () => {
        w = innerWidth * quality;
        h = innerHeight * quality;
        renderer.setSize(w, h);
        persp.aspect = w / h;
        persp.updateProjectionMatrix();
        uniforms.u_resolution.value.set(w, h);
      });
    </script>
  </body>
</html>
