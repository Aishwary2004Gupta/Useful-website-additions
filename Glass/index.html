<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactable Water Sphere (Fully Fixed)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <!-- 100% Working Three.js ES Module Import -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      // ---------------------------------------------
      // SCENE SETUP
      // ---------------------------------------------
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      camera.position.set(-5, 0, -2.5);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 1));

      // ---------------------------------------------
      // ENVIRONMENT TEXTURE
      // ---------------------------------------------
      let loaded = 0;
      const onLoad = () => loaded++;

      const ENV_URL = "https://s.halvves.com/gregzaal-venicedawn.jpg";

      const textureLoader = new THREE.TextureLoader();
      const reflectionTex = textureLoader.load(ENV_URL, onLoad);
      const refractionTex = textureLoader.load(ENV_URL, onLoad);

      reflectionTex.mapping = THREE.EquirectangularReflectionMapping;
      refractionTex.mapping = THREE.EquirectangularRefractionMapping;

      scene.background = reflectionTex;
      scene.environment = reflectionTex;

      // ---------------------------------------------
      // WATER SPHERE
      // ---------------------------------------------
      const geometry = new THREE.SphereGeometry(2, 128, 128);
      const base = geometry.attributes.position.array.slice();

      const matReflection = new THREE.MeshPhysicalMaterial({
        color: 0xc3e4f9,
        envMap: reflectionTex,
        metalness: 0.3,
        roughness: 0,
        transmission: 1,
        transparent: true,
        ior: 1.1,
        side: THREE.DoubleSide,
      });

      const matRefraction = new THREE.MeshPhysicalMaterial({
        color: 0xc3e4f9,
        envMap: refractionTex,
        roughness: 0,
        ior: 1.1,
        metalness: 0.1,
        transmission: 0.5,
        side: THREE.DoubleSide,
      });

      const meshRefraction = new THREE.Mesh(geometry, matRefraction);
      const meshReflection = new THREE.Mesh(geometry, matReflection);

      const sphere = new THREE.Object3D();
      sphere.add(meshRefraction);
      sphere.add(meshReflection);
      scene.add(sphere);

      // ---------------------------------------------
      // ORBIT CONTROLS
      // ---------------------------------------------
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // ---------------------------------------------
      // INTERACTIVE RIPPLE SYSTEM
      // ---------------------------------------------
      const vertexCount = geometry.attributes.position.count;
      const rippleStrength = new Float32Array(vertexCount).fill(0);
      const rippleVelocity = new Float32Array(vertexCount).fill(0);

      const RIPPLE_FORCE = 0.6;
      const RIPPLE_DAMP = 0.97;
      const RIPPLE_SPEED = 0.03;

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function triggerRipple(pt) {
        const pos = geometry.attributes.position;

        let nearest = 0;
        let mind = Infinity;
        const temp = new THREE.Vector3();

        for (let i = 0; i < vertexCount; i++) {
          temp.set(pos.getX(i), pos.getY(i), pos.getZ(i));
          const d = temp.distanceTo(pt);
          if (d < mind) {
            mind = d;
            nearest = i;
          }
        }
        rippleVelocity[nearest] += RIPPLE_FORCE;
      }

      function onPointerEvent(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);
        const hit = raycaster.intersectObject(meshReflection)[0];
        if (hit) triggerRipple(hit.point);
      }

      window.addEventListener("pointermove", onPointerEvent);
      window.addEventListener("pointerdown", onPointerEvent);

      // ---------------------------------------------
      // ANIMATION LOOP
      // ---------------------------------------------
      function animate(t) {
        requestAnimationFrame(animate);
        controls.update();

        if (loaded !== 2) return;

        const pos = geometry.attributes.position;

        // Auto wave motion
        pos.array.forEach((v, i, arr) => {
          const m = i % 3;
          if (m === 0)
            arr[i] = base[i] + Math.sin(base[i + 1] * 3 + t * 0.002) * 0.1;
          if (m === 1)
            arr[i] = base[i] + Math.cos(base[i - 1] * 5 + t * 0.003) * 0.08;
          if (m === 2)
            arr[i] = base[i] + Math.sin(base[i - 2] * 25 + t * 0.01) * 0.03;
        });

        // Ripple physics
        for (let i = 0; i < vertexCount; i++) {
          rippleVelocity[i] += -rippleStrength[i] * RIPPLE_SPEED;
          rippleStrength[i] += rippleVelocity[i];
          rippleVelocity[i] *= RIPPLE_DAMP;
        }

        // Apply ripple displacement
        for (let i = 0; i < vertexCount; i++) {
          const d = rippleStrength[i] * 0.2;
          pos.setY(i, pos.getY(i) + d);
        }

        geometry.computeVertexNormals();
        geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
