<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depixelation Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 150px;
        }
        #progressValue {
            font-weight: bold;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label>
            Progress:
            <input type="range" id="progressSlider" min="0" max="1" step="0.001" value="0">
            <span id="progressValue">0.000</span>
        </label>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Postprocessing -->
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.35.4/build/postprocessing.min.js"></script>

    <script>
        // Fragment shader (embedded directly)
        const fragmentShader = `
            uniform float progress;
            uniform float time;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            const float LEVELS = 5.0;

            void mainImage( const in vec4 inputColor, const in vec2 uv, out vec4 outputColor ) {
                float basePixelSize = pow(2.0, LEVELS);
                float currentLevel = floor(progress * LEVELS);  

                float currentPixelSize = max(basePixelSize / pow(2.0, currentLevel), 1.0);

                float currentPixelsPerRow = ceil(resolution.x / currentPixelSize);
                float currentPixelsPerCol = ceil(resolution.y / currentPixelSize);
                float currentTotalPixels = currentPixelsPerRow * currentPixelsPerCol;
                
                float levelProgress = fract(progress * LEVELS) * currentTotalPixels;
                float currentRowInLevel = floor(levelProgress / currentPixelsPerRow);
                float currentPixelInRow = mod(levelProgress, currentPixelsPerRow);
                
                vec2 gridPos = floor(uv * resolution / currentPixelSize);
                float row = floor(currentPixelsPerCol - gridPos.y - 1.0);
                float posInRow = floor(gridPos.x);
                
                vec4 additionalColor = vec4(0.0, 0.0, 0.0, 1.0);
                vec2 finalUv;
                vec2 finalNormalizedPixelSize;
                
                if (currentPixelSize <= 1.0) {
                    finalUv = uv;
                    additionalColor = vec4(0.0);
                } else if (row < currentRowInLevel || (row == currentRowInLevel && posInRow <= currentPixelInRow)) {
                    finalNormalizedPixelSize = currentPixelSize / resolution;
                    vec2 uvPixel = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
                    finalUv = uvPixel;
                    
                    if (row == currentRowInLevel) {
                        float rand = random(vec2(posInRow, row));
                        float twinkle = sin(time * 10.0 + rand * 10.0) + 1.0;
                        additionalColor = vec4(0.005) * (twinkle * 20.0);
                    }
                } else {
                    float finalPixelSize = currentPixelSize * 2.0;
                    finalNormalizedPixelSize = finalPixelSize / resolution;
                    vec2 uvPixel = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
                    finalUv = uvPixel;
                }

                vec4 color = texture2D(inputBuffer, finalUv);
                outputColor = color + additionalColor;
            }
        `;

        // Custom Effect class
        class CustomDepixelationEffectImpl extends PostProcessing.Effect {
            constructor({ progress = 0.5 }) {
                const uniforms = new Map([
                    ['progress', new THREE.Uniform(progress)]
                ]);
                super('CustomDepixelationEffect', fragmentShader, { uniforms });
            }

            update(renderer, inputBuffer, deltaTime) {
                this.uniforms.get('progress').value = this.progress;
            }
        }

        // Setup scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x74B7FF);

        // Orthographic Camera
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 500);
        camera.position.z = 10;
        camera.zoom = 100;
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Image texture
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg');
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        // Fullscreen quad
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: texture });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Lights (for potential shadows, though not used here)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 10.0);
        directionalLight.position.set(5, 10, -5);
        scene.add(directionalLight);

        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        // Postprocessing
        const composer = new PostProcessing.EffectComposer(renderer);
        const renderPass = new PostProcessing.RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Custom effect
        const effect = new CustomDepixelationEffectImpl({ progress: 0 });
        const effectPass = new PostProcessing.EffectPass(camera, effect);
        composer.addPass(effectPass);

        // UI Controls
        const slider = document.getElementById('progressSlider');
        const progressValue = document.getElementById('progressValue');
        let targetProgress = 0;
        let smoothProgress = 0;
        const damping = 0.25;

        slider.addEventListener('input', (e) => {
            targetProgress = parseFloat(e.target.value);
            progressValue.textContent = targetProgress.toFixed(3);
        });

        // Resize handler
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            composer.setSize(width, height);
        });

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            // Smooth damping
            smoothProgress = THREE.MathUtils.lerp(smoothProgress, targetProgress, damping);
            effect.progress = smoothProgress;

            // Rotate mesh to match camera (like in original)
            mesh.quaternion.copy(camera.quaternion);

            controls.update();
            composer.render();
        }

        animate(0);
    </script>
</body>
</html>