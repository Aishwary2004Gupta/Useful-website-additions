<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Text Effect</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- CONFIGURATION ---
    const textToShow = "AJ";
    const fontSize = 500;
    const fontFace = "Bold Arial, sans-serif";

    // --- SETUP SCENE ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- CREATE TEXT TEXTURE ---
    // We draw the text on a canvas first to use as a texture
    const textCanvas = document.createElement('canvas');
    const ctx = textCanvas.getContext('2d');
    textCanvas.width = 1024;
    textCanvas.height = 1024;
    
    ctx.fillStyle = "white";
    ctx.font = `${fontSize}px ${fontFace}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(textToShow, textCanvas.width / 2, textCanvas.height / 2);

    const textTexture = new THREE.CanvasTexture(textCanvas);

    // --- SHADER MATERIAL ---
    const geometry = new THREE.PlaneGeometry(3, 3, 64, 64);
    const material = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {
            uTexture: { value: textTexture },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uPrevMouse: { value: new THREE.Vector2(0, 0) },
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D uTexture;
            uniform vec2 uMouse;
            uniform float uTime;
            varying vec2 vUv;

            void main() {
                vec2 gridUv = vUv;
                
                // Calculate distance from mouse
                float dist = distance(vUv, uMouse);
                
                // Create a "bulge" or "fluid" displacement based on mouse distance
                float strength = 0.15; // How much it distorts
                float radius = 0.25;   // How far the effect reaches
                
                // This math creates the liquid ripple logic
                float edge = smoothstep(radius, 0.0, dist);
                vec2 displacement = normalize(vUv - uMouse) * edge * strength;
                
                // Add a subtle wave animation over time
                displacement.x += sin(vUv.y * 10.0 + uTime) * 0.005;
                
                // Sample the texture with the displaced coordinates
                vec4 color = texture2D(uTexture, vUv - displacement);
                
                gl_FragColor = color;
            }
        `
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // --- INTERACTION ---
    const mouse = new THREE.Vector2(0.5, 0.5);
    const targetMouse = new THREE.Vector2(0.5, 0.5);

    window.addEventListener('mousemove', (e) => {
        // Convert mouse to 0.0 - 1.0 range
        targetMouse.x = e.clientX / window.innerWidth;
        targetMouse.y = 1.0 - (e.clientY / window.innerHeight);
    });

    // --- ANIMATION LOOP ---
    function animate(time) {
        requestAnimationFrame(animate);
        
        // Smooth mouse movement (easing)
        mouse.x += (targetMouse.x - mouse.x) * 0.08;
        mouse.y += (targetMouse.y - mouse.y) * 0.08;
        
        material.uniforms.uMouse.value.set(mouse.x, mouse.y);
        material.uniforms.uTime.value = time * 0.002;
        
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>