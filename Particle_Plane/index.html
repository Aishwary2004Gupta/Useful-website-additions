<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle / Surface Waves</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
      #canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #00000015;
      }
      .dg {
        z-index: 9999 !important;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
      // --- Basic Three.js setup ---
      const scene = new THREE.Scene();
      const canvas = document.querySelector("#canvas");

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 2.2, 7);

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      const clock = new THREE.Clock();

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 7);
      scene.add(ambient, dir);

      const textureLoader = new THREE.TextureLoader();
      const particleTexture = textureLoader.load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      // --- Parameters ---
      const params = {
        mode: "particles", // "particles" | "surface"

        // shared / wave
        amplitude: 1.0,
        frequency: 1.5,
        speed: 1.0,

        // particles
        particleCount: 20000,
        particleSize: 0.12,
        width: 12,
        height: 12,

        // surface
        segments: 140,
        wireframe: true,
        colorMap: "height", // "height" | "coolwarm"
      };

      // Apply comfy defaults per mode
      function applyParticlesDefaults() {
        params.particleCount = 20000;
        params.particleSize = 0.12;
        params.width = 14;
        params.height = 14;
        params.amplitude = 1.1;
        params.frequency = 1.6;
        params.speed = 1.2;
      }

      function applySurfaceDefaults() {
        params.segments = 140;
        params.width = 12;
        params.height = 12;
        params.amplitude = 1.4;
        params.frequency = 1.4;
        params.speed = 0.9;
        params.wireframe = true;
        params.colorMap = "coolwarm";
      }

      // --- Helpers / geometry refs ---
      let points = null;
      let surface = null;
      let wireframeMesh = null;

      function disposeObjects() {
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        if (surface) {
          scene.remove(surface);
          surface.geometry.dispose();
          surface.material.dispose();
          surface = null;
        }
        if (wireframeMesh) {
          scene.remove(wireframeMesh);
          wireframeMesh.geometry.dispose();
          wireframeMesh.material.dispose();
          wireframeMesh = null;
        }
      }

      function heightToColor(t, scheme = "height") {
        t = THREE.MathUtils.clamp(t, 0, 1);
        if (scheme === "coolwarm") {
          const r = Math.min(1, 2 * t);
          const g = 1 - Math.abs(2 * t - 1);
          const b = Math.min(1, 2 * (1 - t));
          return new THREE.Color(r, g * 0.85, b * 0.9);
        }
        const c = new THREE.Color();
        if (t < 0.33) {
          c.setRGB(0, 0.3 + t * 1.8, 1 - t * 2.7);
        } else if (t < 0.66) {
          const tt = (t - 0.33) / 0.33;
          c.setRGB(0.0 + tt * 0.4, 0.9, 0.0 + tt * 0.6);
        } else {
          const tt = (t - 0.66) / 0.34;
          c.setRGB(0.4 + tt * 0.6, 0.9 - tt * 0.7, 0.6 - tt * 0.6);
        }
        return c;
      }

      // --- Particles mode ---
      function createParticles() {
        disposeObjects();

        const count = Math.max(
          1000,
          Math.min(50000, Math.floor(params.particleCount))
        );
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const x = (Math.random() - 0.5) * params.width;
          const z = (Math.random() - 0.5) * params.height;
          positions[i3] = x;
          positions[i3 + 1] = 0;
          positions[i3 + 2] = z;

          const c = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: params.particleSize,
          sizeAttenuation: true,
          transparent: true,
          alphaMap: particleTexture,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      // --- Surface mode ---
      function createSurface() {
        disposeObjects();

        const seg = Math.max(4, Math.floor(params.segments));
        const geometry = new THREE.PlaneBufferGeometry(
          params.width,
          params.height,
          seg,
          seg
        );
        geometry.rotateX(-Math.PI / 2);

        const positions = geometry.attributes.position.array;
        const count = positions.length / 3;
        const colors = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          positions[i3 + 1] = 0;
          const c = heightToColor(0.5, params.colorMap);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }

        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();

        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          shininess: 40,
          side: THREE.DoubleSide,
          flatShading: false,
        });

        surface = new THREE.Mesh(geometry, material);
        scene.add(surface);

        if (params.wireframe) {
          const geo = new THREE.WireframeGeometry(geometry);
          wireframeMesh = new THREE.LineSegments(
            geo,
            new THREE.LineBasicMaterial({ color: 0x111111 })
          );
          scene.add(wireframeMesh);
        }
      }

      // --- Mode switching + rebuild ---
      function rebuild() {
        if (params.mode === "particles") {
          createParticles();
        } else {
          createSurface();
        }
      }

      // --- GUI setup ---
      const gui = new dat.GUI({ width: 300 });
      gui.close(); // closed initially

      const guiControllers = {
        root: [],
        particles: [],
        surface: [],
        waves: [],
      };

      function updateAllControllers() {
        Object.values(guiControllers).forEach((list) =>
          list.forEach((c) => c.updateDisplay())
        );
      }

      const modeCtrl = gui
        .add(params, "mode", ["particles", "surface"])
        .name("Display Mode")
        .onChange((value) => {
          if (value === "particles") {
            applyParticlesDefaults();
          } else {
            applySurfaceDefaults();
          }
          rebuild();
          updateAllControllers();
        });
      guiControllers.root.push(modeCtrl);

      const pFolder = gui.addFolder("âœ¨ Particles");
      guiControllers.particles.push(
        pFolder
          .add(params, "particleCount", 1000, 50000, 1000)
          .name("Count")
          .onFinishChange(() => {
            if (params.mode === "particles") rebuild();
          })
      );
      guiControllers.particles.push(
        pFolder
          .add(params, "particleSize", 0.01, 0.5, 0.01)
          .name("Size")
          .onChange(() => {
            if (points) points.material.size = params.particleSize;
          })
      );
      guiControllers.particles.push(
        pFolder
          .add(params, "width", 2, 40, 0.5)
          .name("Width")
          .onFinishChange(() => {
            if (params.mode === "particles") rebuild();
          })
      );
      guiControllers.particles.push(
        pFolder
          .add(params, "height", 2, 40, 0.5)
          .name("Depth")
          .onFinishChange(() => {
            if (params.mode === "particles") rebuild();
          })
      );
      pFolder.close();

      const sFolder = gui.addFolder("ðŸŒŠ Surface");
      guiControllers.surface.push(
        sFolder
          .add(params, "segments", 4, 300, 1)
          .name("Detail")
          .onFinishChange(() => {
            if (params.mode === "surface") rebuild();
          })
      );
      guiControllers.surface.push(
        sFolder
          .add(params, "width", 2, 40, 0.5)
          .name("Width")
          .onFinishChange(() => {
            if (params.mode === "surface") rebuild();
          })
      );
      guiControllers.surface.push(
        sFolder
          .add(params, "height", 2, 40, 0.5)
          .name("Depth")
          .onFinishChange(() => {
            if (params.mode === "surface") rebuild();
          })
      );
      guiControllers.surface.push(
        sFolder
          .add(params, "wireframe")
          .name("Wireframe")
          .onChange(() => {
            if (params.mode === "surface") rebuild();
          })
      );
      guiControllers.surface.push(
        sFolder
          .add(params, "colorMap", ["height", "coolwarm"])
          .name("Color Map")
          .onChange(() => {
            if (params.mode === "surface") rebuild();
          })
      );
      sFolder.close();

      const wFolder = gui.addFolder("ðŸŽ› Waves");
      guiControllers.waves.push(
        wFolder.add(params, "amplitude", 0, 3, 0.01).name("Wave Height")
      );
      guiControllers.waves.push(
        wFolder.add(params, "frequency", 0, 6, 0.01).name("Frequency")
      );
      guiControllers.waves.push(
        wFolder.add(params, "speed", 0, 3, 0.01).name("Speed")
      );
      wFolder.close();

      // Initial comfy defaults for starting mode
      applyParticlesDefaults();
      rebuild();
      updateAllControllers();

      // --- Animation loop ---
      function animate() {
        const t = clock.getElapsedTime() * params.speed;

        if (points) {
          const pos = points.geometry.attributes.position.array;
          const count = pos.length / 3;
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
            pos[i3 + 1] = y;
          }
          points.geometry.attributes.position.needsUpdate = true;
        }

        if (surface) {
          const posAttr = surface.geometry.attributes.position;
          const colAttr = surface.geometry.attributes.color;
          const pos = posAttr.array;
          const colors = colAttr.array;
          const vertCount = posAttr.count;

          let minY = Infinity;
          let maxY = -Infinity;

          for (let i = 0; i < vertCount; i++) {
            const i3 = i * 3;
            const x = pos[i3];
            const z = pos[i3 + 2];
            const y =
              Math.sin((x * 0.5 + t) * params.frequency) *
              Math.cos((z * 0.5 + t) * params.frequency) *
              params.amplitude;
            pos[i3 + 1] = y;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }

          const range = Math.max(0.0001, maxY - minY);
          for (let i = 0; i < vertCount; i++) {
            const i3 = i * 3;
            const y = pos[i3 + 1];
            const tcol = (y - minY) / range;
            const c = heightToColor(tcol, params.colorMap);
            colors[i3] = c.r;
            colors[i3 + 1] = c.g;
            colors[i3 + 2] = c.b;
          }

          posAttr.needsUpdate = true;
          colAttr.needsUpdate = true;
          surface.geometry.computeVertexNormals();

          if (wireframeMesh) {
            wireframeMesh.geometry.dispose();
            wireframeMesh.geometry = new THREE.WireframeGeometry(
              surface.geometry
            );
          }
        }

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      // --- Resize handling ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
