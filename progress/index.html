<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depixelation Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #74B7FF;
        }
        canvas {
            display: block;
        }
        #leva-container {
            position: absolute;
            top: 10px;
            right: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="leva-container"></div>

    <!-- Load Three.js and related libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@react-three/fiber@8.15.16/dist/react-three-fiber.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@react-three/drei@9.88.1/dist/drei-umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leva@0.9.34/dist/leva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/maath@0.9.0/dist/maath.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.32.1/build/postprocessing.js"></script>

    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { Suspense, useRef } = React;
        const { Canvas, useFrame, useThree } = ReactThreeFiber;
        const { OrbitControls, OrthographicCamera, Image } = Drei;
        const { EffectComposer, wrapEffect } = POSTPROCESSING;
        const { Leva, useControls } = LevaLib;
        const { easing } = maath;

        // Fragment shader code
        const fragmentShader = `
            uniform float progress;
            uniform float time;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            const float LEVELS = 5.0;

            void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
                float basePixelSize = pow(2.0, LEVELS);
                float currentLevel = floor(progress * LEVELS);

                float currentPixelSize = max(basePixelSize / pow(2.0, currentLevel), 1.0);

                float currentPixelsPerRow = ceil(resolution.x / currentPixelSize);
                float currentPixelsPerCol = ceil(resolution.y / currentPixelSize);
                float currentTotalPixels = currentPixelsPerRow * currentPixelsPerCol;

                float levelProgress = fract(progress * LEVELS) * currentTotalPixels;
                float currentRowInLevel = floor(levelProgress / currentPixelsPerRow);
                float currentPixelInRow = mod(levelProgress, currentPixelsPerRow);

                vec2 gridPos = floor(uv * resolution / currentPixelSize);
                float row = floor(currentPixelsPerCol - gridPos.y - 1.0);
                float posInRow = floor(gridPos.x);

                vec4 additionalColor = vec4(0.0, 0.0, 0.0, 1.0);
                vec2 finalUv;
                vec2 finalNormalizedPixelSize;

                if (currentPixelSize <= 1.0) {
                    finalUv = uv;
                    additionalColor = vec4(0.0);
                } else if (row < currentRowInLevel || (row == currentRowInLevel && posInRow <= currentPixelInRow)) {
                    finalNormalizedPixelSize = currentPixelSize / resolution;
                    vec2 uvPixel = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
                    finalUv = uvPixel;

                    if (row == currentRowInLevel) {
                        float rand = random(vec2(posInRow, row));
                        float twinkle = sin(time * 10.0 + rand * 10.0) + 1.0;
                        additionalColor = vec4(0.005) * (twinkle * 20.0);
                    }
                } else {
                    float finalPixelSize = currentPixelSize * 2.0;
                    finalNormalizedPixelSize = finalPixelSize / resolution;
                    vec2 uvPixel = finalNormalizedPixelSize * floor(uv / finalNormalizedPixelSize);
                    finalUv = uvPixel;
                }

                vec4 color = texture2D(inputBuffer, finalUv);
                outputColor = color + additionalColor;
            }
        `;

        class CustomDepixelationEffectImpl extends POSTPROCESSING.Effect {
            constructor({ progress = 0.5 }) {
                const uniforms = new Map([
                    ['progress', new THREE.Uniform(progress)],
                    ['time', new THREE.Uniform(0)]
                ]);

                super('CustomDepixelationEffect', fragmentShader, {
                    uniforms,
                });

                this.uniforms = uniforms;
            }

            update(_renderer, _inputBuffer, deltaTime) {
                this.uniforms.get('progress').value = this.progress;
                this.uniforms.get('time').value += deltaTime;
            }
        }

        const CustomDepixelationEffect = wrapEffect(CustomDepixelationEffectImpl);

        const DepixelationEffect = () => {
            const effectRef = useRef();
            const smoothProgressRef = useRef(0);

            const { progress } = useControls({
                progress: {
                    value: 0.0,
                    min: 0.0,
                    max: 1.0,
                    step: 0.001,
                },
            });

            useFrame((state) => {
                const { camera } = state;

                easing.damp(smoothProgressRef, 'current', progress, 0.25);

                if (effectRef.current) {
                    effectRef.current.progress = smoothProgressRef.current;
                }

                camera.lookAt(0, 0, 0);
            });

            return (
                <EffectComposer>
                    <CustomDepixelationEffect ref={effectRef} progress={progress} />
                </EffectComposer>
            );
        };

        const FullScreenImage = () => {
            const meshRef = useRef();
            const { viewport } = useThree();

            useFrame((state) => {
                const { camera } = state;
                meshRef.current.rotation.setFromQuaternion(camera.quaternion);
            });

            return (
                <Image
                    ref={meshRef}
                    scale={[viewport.width, viewport.height, 1.0]}
                    url='https://cdn.maximeheckel.com/images/backgrounds/gril-with-pearl-earing.jpg'
                />
            );
        };

        const Depixelation = () => {
            return (
                <>
                    <OrthographicCamera
                        makeDefault
                        position={[0, 0, 10]}
                        zoom={100}
                        near={0.01}
                        far={500}
                    />
                    <FullScreenImage />
                    <DepixelationEffect />
                </>
            );
        };

        const Scene = () => {
            return (
                <>
                    <Canvas shadows dpr={[1, 1.5]}>
                        <Suspense>
                            <color attach='background' args={['#74B7FF']} />
                            <ambientLight intensity={0.5} />
                            <directionalLight position={[5, 10, -5]} intensity={10.0} />
                            <OrbitControls />
                            <Depixelation />
                        </Suspense>
                    </Canvas>
                    <Leva collapsed />
                </>
            );
        };

        // Render the scene
        ReactDOM.createRoot(document.getElementById('root')).render(<Scene />);
    </script>
</body>
</html>