<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Jelly Switch (Three.js Version)</title>
  <style>
    body {
      margin: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>

<body>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

// ------------------------------------------------------
// Basic scene setup
// ------------------------------------------------------
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(devicePixelRatio);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2.2, 2.9, 3.5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ------------------------------------------------------
// Lighting
// ------------------------------------------------------
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(1.4, 2, 1.2);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// ------------------------------------------------------
// Environment map (soft reflections)
// ------------------------------------------------------
const pmrem = new THREE.PMREMGenerator(renderer);
const envRT = pmrem.fromScene(new THREE.Scene(), 0.1);
const envMap = envRT ? envRT.texture : null;

// ------------------------------------------------------
// Ground Plane
// ------------------------------------------------------
const ground = new THREE.Mesh(
  new THREE.BoxGeometry(4, 0.2, 2),
  new THREE.MeshStandardMaterial({
    color: 0x222222,
    roughness: 0.8,
    metalness: 0.2
  })
);
ground.position.y = -0.6;
scene.add(ground);

// ------------------------------------------------------
// Jelly slider geometry
// ------------------------------------------------------
const jellyGeo = new THREE.BoxGeometry(1.2, 0.6, 0.6, 20, 20, 20);

// Custom vertex shader deformation
const jellyMat = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color(1.0, 0.45, 0.07),
  roughness: 0,
  metalness: 0,
  clearcoat: 1,
  clearcoatRoughness: 0.05,
  transmission: 1,
  thickness: 1.0,
  envMap,
  envMapIntensity: 1.2,
  ior: 1.42
});

const jelly = new THREE.Mesh(jellyGeo, jellyMat);
scene.add(jelly);

// Track
const track = new THREE.Mesh(
  new THREE.BoxGeometry(3.2, 0.15, 0.4),
  new THREE.MeshStandardMaterial({
    color: 0x333333,
    metalness: 0.1,
    roughness: 0.7
  })
);
track.position.y = -0.2;
scene.add(track);

// ------------------------------------------------------
// Physics & Switch Animation (Springs)
// ------------------------------------------------------
let toggled = false;
let pressed = false;

let progress = 0;
let velocity = 0;
const accel = 6; // slider speed

let squashX = 0;
let squashZ = 0;
let wiggle = 0;

// ------------------------------------------------------
// Spring helpers
// ------------------------------------------------------
function spring(value, target, vel, k = 12, d = 2, dt = 0.016) {
  const force = -k * (value - target);
  const damping = -d * vel;
  const a = (force + damping);
  vel += a * dt;
  value += vel * dt;
  return [value, vel];
}

// ------------------------------------------------------
// Interaction
// ------------------------------------------------------
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function updatePointer(e) {
  pointer.x = (e.clientX / innerWidth) * 2 - 1;
  pointer.y = -(e.clientY / innerHeight) * 2 + 1;
}

window.addEventListener("mousedown", e => {
  updatePointer(e);
  raycaster.setFromCamera(pointer, camera);
  const hit = raycaster.intersectObject(jelly);
  if (hit.length) {
    pressed = true;
  }
});

window.addEventListener("mouseup", () => {
  if (pressed) toggled = !toggled;
  pressed = false;
});

// ------------------------------------------------------
// Animation Loop
// ------------------------------------------------------
function animate(t) {

  // Update slider movement
  const target = toggled ? 1 : 0;

  // smooth slide
  const dt = 0.016;
  const targetAcc = (target - progress) * accel;
  velocity += targetAcc * dt;
  velocity *= 0.85;
  progress += velocity * dt;
  progress = Math.min(1, Math.max(0, progress));

  // Springs for squash/stretch
  const squashTargetX = pressed ? -0.25 : 0;
  const squashTargetZ = pressed ? 0.3 : 0;

  [squashX, velX] = spring(squashX, squashTargetX, 0);
  [squashZ, velZ] = spring(squashZ, squashTargetZ, 0);

  // wiggle based on velocity
  [wiggle, velW] = spring(wiggle, velocity * 0.4, 0);

  // --------------------------------------------------
  // Apply deformation
  // --------------------------------------------------
  jelly.scale.set(
    1 + squashX,
    1 - squashX * 0.5,
    1 + squashZ
  );

  // position along track
  jelly.position.x = THREE.MathUtils.lerp(-1.3, 1.3, progress);

  // wiggle rotation
  jelly.rotation.z = wiggle * 0.3;

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
