<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Morphing Glass Cube</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Lights ---
        const light1 = new THREE.PointLight(0xff00ff, 10, 10); // Neon Pink
        light1.position.set(2, 2, 2);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x00ffff, 10, 10); // Neon Cyan
        light2.position.set(-2, -2, 2);
        scene.add(light2);

        // --- 1. The Cube Outline ---
        const cubeSize = 2;
        const boxGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const edgeGeo = new THREE.EdgesGeometry(boxGeo); // Creates clean outlines
        const edgeMat = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 });
        const cubeOutline = new THREE.LineSegments(edgeGeo, edgeMat);
        scene.add(cubeOutline);

        // --- 2. The Glass Shell ---
        const glassMat = new THREE.MeshPhysicalMaterial({
            transmission: 1,
            thickness: 0.5,
            roughness: 0.05,
            ior: 1.5,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const glassCube = new THREE.Mesh(boxGeo, glassMat);
        scene.add(glassCube);

        // --- 3. The Morphing Blob (Inside) ---
        // Using a high-poly Sphere as the base for morphing
        const blobGeo = new THREE.IcosahedronGeometry(0.7, 32); 
        const blobMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0,
            metalness: 1,
            emissive: 0x220044
        });
        const blob = new THREE.Mesh(blobGeo, blobMat);
        scene.add(blob);

        // Store original positions for the morphing math
        const positionAttribute = blobGeo.attributes.position;
        const vertex = new THREE.Vector3();
        const originalPositions = new Float32Array(positionAttribute.array);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- Animation Loop ---
        let time = 0;

        function animate() {
            time += 0.02;
            requestAnimationFrame(animate);

            // Rotate Everything
            cubeOutline.rotation.y += 0.005;
            glassCube.rotation.y = cubeOutline.rotation.y;
            blob.rotation.y -= 0.01;

            // --- SMOOTH MORPHING LOGIC ---
            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromArray(originalPositions, i * 3);
                
                // Using Perlin-like noise math to displace vertices
                const wave1 = Math.sin(vertex.x * 2 + time) * 0.2;
                const wave2 = Math.cos(vertex.y * 3 + time) * 0.15;
                const wave3 = Math.sin(vertex.z * 2.5 + time) * 0.2;
                
                // Calculate the "Morphed" distance
                const offset = 1 + (wave1 + wave2 + wave3);
                
                vertex.multiplyScalar(offset); 
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            positionAttribute.needsUpdate = true; // Tell WebGL to re-render geometry
            blobGeo.computeVertexNormals(); // Fix lighting on morphed surface

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>